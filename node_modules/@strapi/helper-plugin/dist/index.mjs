import * as React from "react";
import React__default, { useMemo, useCallback, useState, useEffect, useRef } from "react";
import { EmptyStateLayout as EmptyStateLayout$1, Flex as Flex$1, Alert, Loader, Dialog, Box as Box$1, DialogBody, DialogFooter, Button, Typography as Typography$1, DateTimePicker, Tbody, Tr, Td, Table as Table$2, Thead, Th, BaseCheckbox, IconButton, Tooltip, VisuallyHidden, Tag, Popover, SingleSelect, SingleSelectOption, DatePicker, NumberInput, TimePicker, Field, FieldInput, TextInput, Textarea, Icon, Checkbox, ToggleInput, JSONInput, Pagination, PreviousLink, PageLink, Dots, NextLink, SearchForm, Searchbar } from "@strapi/design-system";
import { ExclamationMarkCircle, ExternalLink, Trash, CarretDown, EmptyDocuments, EmptyPictures, EmptyPermissions, Cross, Plus, Eye, EyeStriked, Search, Refresh, Clock, Minus } from "@strapi/icons";
import { useIntl } from "react-intl";
import { Redirect, useLocation, useHistory, NavLink } from "react-router-dom";
import styled, { css, useTheme, keyframes } from "styled-components";
import axios from "axios";
import qs, { parse as parse$1, stringify as stringify$1 } from "qs";
import { useFormikContext, Form as Form$1 } from "formik";
import Select, { components } from "react-select";
import { intervalToDuration, isPast } from "date-fns";
import { Helmet } from "react-helmet";
import { createPortal } from "react-dom";
import { useQueries } from "react-query";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min)
    return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = React__default, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for (b in a)
      m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps)
      for (b in a = c.defaultProps, a)
        void 0 === d[b] && (d[b] = a[b]);
    return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development)
    return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var React2 = React__default;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (; s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty2);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray2(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      var didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty2.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty2.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self2) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== void 0) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self2);
          }
          for (propName in config) {
            if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray2(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === void 0 || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys2 = Object.keys(fragment.props);
          for (var i = 0; i < keys2.length; i++) {
            var key = keys2[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum(source);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray2(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self2);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== void 0) {
              if (isStaticChildren) {
                if (isArray2(children)) {
                  for (var i = 0; i < children.length; i++) {
                    validateChildKeys(children[i], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      function jsxWithValidationStatic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, true);
        }
      }
      function jsxWithValidationDynamic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, false);
        }
      }
      var jsx = jsxWithValidationDynamic;
      var jsxs = jsxWithValidationStatic;
      reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_development.jsx = jsx;
      reactJsxRuntime_development.jsxs = jsxs;
    })();
  }
  return reactJsxRuntime_development;
}
if (process.env.NODE_ENV === "production") {
  jsxRuntime.exports = requireReactJsxRuntime_production_min();
} else {
  jsxRuntime.exports = requireReactJsxRuntime_development();
}
var jsxRuntimeExports = jsxRuntime.exports;
const AnErrorOccurred = ({
  content = {
    id: "anErrorOccurred",
    defaultMessage: "Woops! Something went wrong. Please, try again.",
    values: {}
  },
  ...rest
}) => {
  const { formatMessage } = useIntl();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    EmptyStateLayout$1,
    {
      ...rest,
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(ExclamationMarkCircle, { width: "10rem" }),
      content: formatMessage(
        { id: content.id, defaultMessage: content.defaultMessage },
        content.values
      )
    }
  );
};
const handleResponsiveValues = (property2, value, theme) => {
  if (!value) {
    return void 0;
  }
  let transformedArray = Array.isArray(value) ? value : [];
  if (!Array.isArray(value) && typeof value === "object") {
    transformedArray = [value == null ? void 0 : value.desktop, value == null ? void 0 : value.tablet, value == null ? void 0 : value.mobile];
  }
  if (transformedArray.length > 0) {
    const spaces = transformedArray.reduce((acc, curr, index) => {
      if (curr) {
        switch (index) {
          case 0:
            return `${acc}${property2}: ${theme.spaces[curr]};`;
          case 1:
            return `${acc}${theme.mediaQueries.tablet}{${property2}: ${theme.spaces[curr]};}`;
          case 2:
            return `${acc}${theme.mediaQueries.mobile}{${property2}: ${theme.spaces[curr]};}`;
          default:
            return acc;
        }
      }
      return acc;
    }, "");
    return spaces;
  }
  const realValue = theme.spaces[value] || value;
  return `${property2}: ${realValue};`;
};
function isKeyOf(o, s) {
  if (typeof o === "string") {
    return false;
  }
  return s in o;
}
function extractStyleFromTheme(themeSection, key, defaultValue) {
  if (key && isKeyOf(themeSection, key)) {
    return themeSection[key];
  }
  return defaultValue;
}
const transientProps$3 = {
  color: true,
  cursor: true,
  height: true,
  width: true
};
const Box = styled.div.withConfig({
  shouldForwardProp: (prop, defPropValFN) => !transientProps$3[prop] && defPropValFN(prop)
})`
  // Font
  font-size: ${({ fontSize, theme }) => extractStyleFromTheme(theme.fontSizes, fontSize, fontSize)};

  // Colors
  background: ${({ theme, background }) => extractStyleFromTheme(theme.colors, background, background)};
  color: ${({ theme, color }) => extractStyleFromTheme(theme.colors, color, void 0)};

  // Spaces
  ${({ theme, padding }) => handleResponsiveValues("padding", padding, theme)}
  ${({ theme, paddingTop }) => handleResponsiveValues("padding-top", paddingTop, theme)}
  ${({ theme, paddingRight }) => handleResponsiveValues("padding-right", paddingRight, theme)}
  ${({ theme, paddingBottom }) => handleResponsiveValues("padding-bottom", paddingBottom, theme)}
  ${({ theme, paddingLeft }) => handleResponsiveValues("padding-left", paddingLeft, theme)}
  ${({ theme, marginLeft }) => handleResponsiveValues("margin-left", marginLeft, theme)}
  ${({ theme, marginRight }) => handleResponsiveValues("margin-right", marginRight, theme)}
  ${({ theme, marginTop }) => handleResponsiveValues("margin-top", marginTop, theme)}
  ${({ theme, marginBottom }) => handleResponsiveValues("margin-bottom", marginBottom, theme)}

  // Responsive hiding
  ${({ theme, hiddenS }) => hiddenS ? `${theme.mediaQueries.tablet} { display: none; }` : void 0}
  ${({ theme, hiddenXS }) => hiddenXS ? `${theme.mediaQueries.mobile} { display: none; }` : void 0}
  

  // Borders
  border-radius: ${({ theme, hasRadius, borderRadius }) => hasRadius ? theme.borderRadius : borderRadius};
  border-style: ${({ borderStyle }) => borderStyle};
  border-width: ${({ borderWidth }) => borderWidth};
  border-color: ${({ borderColor, theme }) => extractStyleFromTheme(theme.colors, borderColor, void 0)};
  border: ${({ theme, borderColor, borderStyle, borderWidth }) => {
  if (borderColor && !borderStyle && typeof borderWidth === "undefined") {
    return `1px solid ${theme.colors[borderColor]}`;
  }
  return void 0;
}};

  // Shadows
  box-shadow: ${({ theme, shadow }) => extractStyleFromTheme(theme.shadows, shadow, void 0)};

  // Handlers
  pointer-events: ${({ pointerEvents }) => pointerEvents};
  &:hover {
    ${({ _hover, theme }) => _hover ? _hover(theme) : void 0}
  }

  // Display
  display: ${({ display }) => display};

  // Position
  position: ${({ position }) => position};
  left: ${({ left, theme }) => extractStyleFromTheme(theme.spaces, left, left)};
  right: ${({ right, theme }) => extractStyleFromTheme(theme.spaces, right, right)};
  top: ${({ top, theme }) => extractStyleFromTheme(theme.spaces, top, top)};
  bottom: ${({ bottom, theme }) => extractStyleFromTheme(theme.spaces, bottom, bottom)};
  z-index: ${({ zIndex }) => zIndex};
  overflow: ${({ overflow }) => overflow};

  // Size
  width: ${({ width, theme }) => extractStyleFromTheme(theme.spaces, width, width)};
  max-width: ${({ maxWidth, theme }) => extractStyleFromTheme(theme.spaces, maxWidth, maxWidth)};
  min-width: ${({ minWidth, theme }) => extractStyleFromTheme(theme.spaces, minWidth, minWidth)};
  height: ${({ height, theme }) => extractStyleFromTheme(theme.spaces, height, height)};
  max-height: ${({ maxHeight, theme }) => extractStyleFromTheme(theme.spaces, maxHeight, maxHeight)};
  min-height: ${({ minHeight, theme }) => extractStyleFromTheme(theme.spaces, minHeight, minHeight)};

  // Animation
  transition: ${({ transition }) => transition};
  transform: ${({ transform: transform2 }) => transform2};
  animation: ${({ animation }) => animation};

  //Flexbox children props
  flex-shrink: ${({ shrink }) => shrink};
  flex-grow: ${({ grow }) => grow};
  flex-basis: ${({ basis }) => basis};
  flex: ${({ flex }) => flex};

  // Text
  text-align: ${({ textAlign }) => textAlign};
  text-transform: ${({ textTransform }) => textTransform};
  line-height: ${({ theme, lineHeight }) => extractStyleFromTheme(theme.lineHeights, lineHeight, lineHeight)};

  // Cursor
  cursor: ${({ cursor }) => cursor};
`;
const ALPHA = "alpha";
const BETA = "beta";
const DELTA = "delta";
const EPSILON = "epsilon";
const OMEGA = "omega";
const PI = "pi";
const SIGMA = "sigma";
const ellipsisStyle = ({ ellipsis = false }) => ellipsis && `
    display: block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  `;
const variantStyle = ({ variant = OMEGA, theme }) => {
  switch (variant) {
    case ALPHA: {
      return `
        font-weight: ${theme.fontWeights.bold};
        font-size: ${theme.fontSizes[5]};
        line-height: ${theme.lineHeights[2]};
      `;
    }
    case BETA: {
      return `
        font-weight: ${theme.fontWeights.bold};
        font-size: ${theme.fontSizes[4]};
        line-height: ${theme.lineHeights[1]};
      `;
    }
    case DELTA: {
      return `
        font-weight: ${theme.fontWeights.semiBold};
        font-size: ${theme.fontSizes[3]};
        line-height: ${theme.lineHeights[2]};
      `;
    }
    case EPSILON: {
      return `
        font-size: ${theme.fontSizes[3]};
        line-height: ${theme.lineHeights[6]};
      `;
    }
    case OMEGA: {
      return `
        font-size: ${theme.fontSizes[2]};
        line-height: ${theme.lineHeights[4]};
      `;
    }
    case PI: {
      return `
        font-size: ${theme.fontSizes[1]};
        line-height: ${theme.lineHeights[3]};
      `;
    }
    case SIGMA: {
      return `
        font-weight: ${theme.fontWeights.bold};
        font-size: ${theme.fontSizes[0]};
        line-height: ${theme.lineHeights[5]};
        text-transform: uppercase;
      `;
    }
    default: {
      return `
        font-size: ${theme.fontSizes[2]};
      `;
    }
  }
};
const transientProps$2 = {
  fontSize: true,
  fontWeight: true
};
const Typography = styled.span.withConfig({
  shouldForwardProp: (prop, defPropValFN) => !transientProps$2[prop] && defPropValFN(prop)
})`
  ${variantStyle}
  ${ellipsisStyle}

  // These properties need to come after {variantStyle}, because they might
  // overwrite a variant attribute
  font-weight: ${({ theme, fontWeight }) => extractStyleFromTheme(theme.fontWeights, fontWeight, void 0)};
  font-size: ${({ theme, fontSize }) => extractStyleFromTheme(theme.fontSizes, fontSize, void 0)};
  line-height: ${({ theme, lineHeight }) => extractStyleFromTheme(theme.lineHeights, lineHeight, lineHeight)};
  color: ${({ theme, textColor }) => theme.colors[textColor || "neutral800"]};
  text-align: ${({ textAlign }) => textAlign};
  text-decoration: ${({ textDecoration }) => textDecoration};
  text-transform: ${({ textTransform }) => textTransform};
`;
const transientProps$1 = {
  direction: true
};
const Flex = styled(Box).withConfig({
  shouldForwardProp: (prop, defPropValFN) => !transientProps$1[prop] && defPropValFN(prop)
})`
  align-items: ${({ alignItems = "center" }) => alignItems};
  display: ${({ display = "flex", inline }) => inline ? "inline-flex" : display};
  flex-direction: ${({ direction = "row" }) => direction};
  flex-shrink: ${({ shrink }) => shrink};
  flex-wrap: ${({ wrap }) => wrap};
  ${({ gap, theme }) => handleResponsiveValues("gap", gap, theme)};
  justify-content: ${({ justifyContent }) => justifyContent};
`;
const BaseLink = React__default.forwardRef(({ href, rel = "noreferrer noopener", target = "_self", disabled = false, isExternal = false, ...props }, ref) => {
  return jsxRuntimeExports.jsx(Box, { as: "a", ref, target: isExternal ? "_blank" : target, rel: isExternal ? rel : void 0, href: disabled ? "#" : href, "aria-disabled": disabled, cursor: "pointer", ...props });
});
BaseLink.displayName = "BaseLink";
const buttonFocusStyle = ({ theme }) => css`
  position: relative;
  outline: none;

  &:after {
    transition-property: all;
    transition-duration: 0.2s;
    border-radius: 8px;
    content: '';
    position: absolute;
    top: -4px;
    bottom: -4px;
    left: -4px;
    right: -4px;
    border: 2px solid transparent;
  }

  &:focus-visible {
    outline: none;
    &:after {
      border-radius: 8px;
      content: '';
      position: absolute;
      top: -5px;
      bottom: -5px;
      left: -5px;
      right: -5px;
      border: 2px solid ${theme.colors.primary600};
    }
  }
`;
const LinkWrapper$1 = styled(BaseLink)`
  display: inline-flex;
  align-items: center;
  text-decoration: none;
  gap: ${({ theme }) => theme.spaces[2]};
  pointer-events: ${({ disabled }) => disabled ? "none" : void 0};

  svg {
    font-size: ${10 / 16}rem;

    path {
      fill: ${({ disabled, theme }) => disabled ? theme.colors.neutral600 : theme.colors.primary600};
    }
  }

  &:hover {
    color: ${({ theme }) => theme.colors.primary500};
  }

  &:active {
    color: ${({ theme }) => theme.colors.primary700};
  }

  ${buttonFocusStyle};
`;
const Link$1 = React__default.forwardRef(({ children, href, disabled = false, startIcon, endIcon, isExternal = true, ...props }, ref) => {
  return jsxRuntimeExports.jsxs(LinkWrapper$1, { ref, href, disabled, isExternal, ...props, children: [startIcon, jsxRuntimeExports.jsx(Typography, { textColor: disabled ? "neutral600" : "primary600", children }), endIcon, href && !endIcon && isExternal && jsxRuntimeExports.jsx(ExternalLink, {})] });
});
Link$1.displayName = "Link";
const SUCCESS_LIGHT = "success-light";
const DANGER_LIGHT = "danger-light";
const DEFAULT = "default";
const TERTIARY = "tertiary";
const SECONDARY = "secondary";
const DANGER = "danger";
const SUCCESS = "success";
const GHOST = "ghost";
const LIGHT_VARIANTS = [SUCCESS_LIGHT, DANGER_LIGHT];
const VARIANTS = [DEFAULT, TERTIARY, SECONDARY, DANGER, SUCCESS, GHOST, ...LIGHT_VARIANTS];
const getVariantColorName = (variant) => {
  if (variant === SUCCESS_LIGHT || variant === DANGER_LIGHT) {
    return `${variant.substring(0, variant.lastIndexOf("-"))}`;
  }
  if (variant === TERTIARY) {
    return "neutral";
  }
  if (variant === DEFAULT || variant === SECONDARY || VARIANTS.every((vari) => vari !== variant)) {
    return "primary";
  }
  return `${variant}`;
};
const getDisabledStyle = ({ theme }) => {
  return `
    border: 1px solid ${theme.colors.neutral200};
    background: ${theme.colors.neutral150};
    ${Typography} {
      color: ${theme.colors.neutral600};
    }
    svg {
      > g, path {
        fill: ${theme.colors.neutral600};
      }
    }
  `;
};
const getHoverStyle = ({ theme, variant }) => {
  if ([...LIGHT_VARIANTS, SECONDARY].includes(variant)) {
    return `
      background-color: ${theme.colors.neutral0};
    `;
  }
  if (variant === TERTIARY) {
    return `
      background-color: ${theme.colors.neutral100};
    `;
  }
  if (variant === GHOST) {
    return `
      background-color: ${theme.colors.neutral100};
    `;
  }
  if (variant === DEFAULT) {
    return `
      border: 1px solid ${theme.colors.buttonPrimary500};
      background: ${theme.colors.buttonPrimary500};
    `;
  }
  return `
    border: 1px solid ${theme.colors[`${getVariantColorName(variant)}500`]};
    background: ${theme.colors[`${getVariantColorName(variant)}500`]};
  `;
};
const getActiveStyle = ({ theme, variant }) => {
  if ([...LIGHT_VARIANTS, SECONDARY].includes(variant)) {
    return `
      background-color: ${theme.colors.neutral0};
      border: 1px solid ${theme.colors[`${getVariantColorName(variant)}600`]};
      ${Typography} {
        color: ${theme.colors[`${getVariantColorName(variant)}600`]};
      }
      svg {
        > g, path {
          fill: ${theme.colors[`${getVariantColorName(variant)}600`]};
        }
      }
    `;
  }
  if (variant === TERTIARY) {
    return `
      background-color: ${theme.colors.neutral150};
    `;
  }
  return `
    border: 1px solid ${theme.colors[`${getVariantColorName(variant)}600`]};
    background: ${theme.colors[`${getVariantColorName(variant)}600`]};
  `;
};
const getVariantStyle = ({ theme, variant }) => {
  switch (variant) {
    case DANGER_LIGHT:
    case SUCCESS_LIGHT:
    case SECONDARY: {
      return `
          border: 1px solid ${theme.colors[`${getVariantColorName(variant)}200`]};
          background: ${theme.colors[`${getVariantColorName(variant)}100`]};
          ${Typography} {
            color: ${theme.colors[`${getVariantColorName(variant)}700`]};
          }
          svg {
            > g, path {
              fill: ${theme.colors[`${getVariantColorName(variant)}700`]};
            }
          }
        `;
    }
    case TERTIARY: {
      return `
          border: 1px solid ${theme.colors.neutral200};
          background: ${theme.colors.neutral0};
          ${Typography} {
            color: ${theme.colors.neutral800};
          }
          svg {
            > g, path {
              fill: ${theme.colors.neutral800};
            }
          }
        `;
    }
    case GHOST: {
      return `
        border: 1px solid transparent;
        background: transparent;

        ${Typography} {
          color: ${theme.colors.neutral800};
        }

        svg {
          > g, path {
            fill: ${theme.colors.neutral500};
          }
        }
      `;
    }
    case SUCCESS:
    case DANGER: {
      return `
          border: 1px solid ${theme.colors[`${getVariantColorName(variant)}600`]};
          background: ${theme.colors[`${getVariantColorName(variant)}600`]};
          ${Typography} {
            color: ${theme.colors.neutral0};
          }
        `;
    }
    default: {
      return `
          svg {
            > g, path {
              fill: ${theme.colors.buttonNeutral0};
            }
          }
        `;
    }
  }
};
const BaseButtonWrapper = styled(Flex)`
  > svg {
    height: ${({ theme }) => theme.spaces[3]};
    width: ${({ theme }) => theme.spaces[3]};

    > g,
    path {
      fill: ${({ theme }) => theme.colors.neutral0};
    }
  }

  &[aria-disabled='true'] {
    pointer-events: none;
  }

  ${buttonFocusStyle}
`;
const BaseButton = React.forwardRef(({ disabled, children, background = "neutral0", ...props }, ref) => {
  return jsxRuntimeExports.jsx(BaseButtonWrapper, { ref, "aria-disabled": disabled, as: "button", type: "button", disabled, padding: 2, hasRadius: true, background, borderColor: "neutral200", cursor: "pointer", ...props, children });
});
BaseButton.displayName = "BaseButton";
const LinkWrapper = styled(BaseButtonWrapper)`
  text-decoration: none;

  &[aria-disabled='true'] {
    ${getDisabledStyle}
    &:active {
      ${getDisabledStyle}
    }
  }

  &:hover {
    ${getHoverStyle}
  }

  &:active {
    ${getActiveStyle}
  }

  ${getVariantStyle}
`;
const LinkButton$1 = React__default.forwardRef(({ variant = "default", startIcon, endIcon, disabled = false, children, size = "S", as = BaseLink, ...props }, ref) => {
  const paddingX = size === "S" ? 2 : "10px";
  const paddingY = 4;
  return jsxRuntimeExports.jsxs(LinkWrapper, { ref, "aria-disabled": disabled, size, variant, background: "buttonPrimary600", borderColor: "buttonPrimary600", hasRadius: true, gap: 2, inline: true, paddingBottom: paddingX, paddingLeft: paddingY, paddingRight: paddingY, paddingTop: paddingX, pointerEvents: disabled ? "none" : void 0, ...props, as: as || BaseLink, children: [startIcon && jsxRuntimeExports.jsx(Flex, { "aria-hidden": true, children: startIcon }), jsxRuntimeExports.jsx(Typography, { variant: size === "S" ? "pi" : void 0, fontWeight: "bold", textColor: "buttonNeutral0", children }), endIcon && jsxRuntimeExports.jsx(Flex, { "aria-hidden": true, children: endIcon })] });
});
LinkButton$1.displayName = "LinkButton";
const useCallbackRef = (callback) => {
  const callbackRef = React.useRef(callback);
  React.useEffect(() => {
    callbackRef.current = callback;
  });
  return React.useMemo(() => (...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, []);
};
const NotificationsContext = React.createContext({
  toggleNotification: () => {
  }
});
const NotificationsProvider = ({ children }) => {
  const notificationIdRef = React.useRef(0);
  const [notifications, setNotifications] = React.useState([]);
  const toggleNotification = React.useCallback(
    ({ type, message, link, timeout, blockTransition, onClose, title }) => {
      setNotifications((s) => [
        ...s,
        {
          id: notificationIdRef.current++,
          type,
          message,
          link,
          timeout,
          blockTransition,
          onClose,
          title
        }
      ]);
    },
    []
  );
  const clearNotification = React.useCallback((id) => {
    setNotifications((s) => s.filter((n) => n.id !== id));
  }, []);
  const value = React.useMemo(() => ({ toggleNotification }), [toggleNotification]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(NotificationsContext.Provider, { value, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Flex$1,
      {
        left: "50%",
        marginLeft: "-250px",
        position: "fixed",
        direction: "column",
        alignItems: "stretch",
        gap: 2,
        top: `${46 / 16}rem`,
        width: `${500 / 16}rem`,
        zIndex: 10,
        children: notifications.map((notification) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Notification,
            {
              ...notification,
              clearNotification
            },
            notification.id
          );
        })
      }
    ),
    children
  ] });
};
const Notification = ({
  clearNotification,
  blockTransition = false,
  id,
  link,
  message = {
    id: "notification.success.saved",
    defaultMessage: "Saved"
  },
  onClose,
  timeout = 2500,
  title = "success",
  type
}) => {
  const { formatMessage } = useIntl();
  const onCloseCallback = useCallbackRef(onClose);
  const handleClose = React.useCallback(() => {
    onCloseCallback();
    clearNotification(id);
  }, [clearNotification, id, onCloseCallback]);
  React.useEffect(() => {
    if (!blockTransition) {
      const timeoutReference = setTimeout(() => {
        handleClose();
      }, timeout);
      return () => {
        clearTimeout(timeoutReference);
      };
    }
  }, [blockTransition, handleClose, timeout]);
  let variant;
  let alertTitle;
  if (type === "info") {
    variant = "default";
    alertTitle = formatMessage({
      id: "notification.default.title",
      defaultMessage: "Information:"
    });
  } else if (type === "warning") {
    variant = "danger";
    alertTitle = formatMessage({
      id: "notification.warning.title",
      defaultMessage: "Warning:"
    });
  } else if (type === "softWarning") {
    variant = "warning";
    alertTitle = formatMessage({
      id: "notification.warning.title",
      defaultMessage: "Warning:"
    });
  } else {
    variant = "success";
    alertTitle = formatMessage({
      id: "notification.success.title",
      defaultMessage: "Success:"
    });
  }
  if (title) {
    alertTitle = typeof title === "string" ? title : formatMessage(
      {
        id: title.id,
        defaultMessage: title.defaultMessage ?? title.id
      },
      title.values
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Alert,
    {
      action: link ? /* @__PURE__ */ jsxRuntimeExports.jsx(Link$1, { href: link.url, isExternal: true, children: formatMessage({
        id: typeof link.label === "object" ? link.label.id : link.label,
        defaultMessage: typeof link.label === "object" ? link.label.defaultMessage ?? link.label.id : link.label
      }) }) : void 0,
      onClose: handleClose,
      closeLabel: formatMessage({
        id: "global.close",
        defaultMessage: "Close"
      }),
      title: alertTitle,
      variant,
      children: formatMessage(
        {
          id: typeof message === "object" ? message.id : message,
          defaultMessage: typeof message === "object" ? message.defaultMessage ?? message.id : message
        },
        typeof message === "object" ? message.values : void 0
      )
    }
  );
};
/**
 * @preserve
 * @description Returns an object to interact with the notification
 * system. The callbacks are wrapped in `useCallback` for a stable
 * identity.
 *
 * @example
 * ```tsx
 * import { useNotification } from '@strapi/helper-plugin';
 *
 * const MyComponent = () => {
 *  const toggleNotification = useNotification();
 *
 *  return <button onClick={() => toggleNotification({ message: 'Hello world!' })}>Click me</button>;
 */
const useNotification = () => React.useContext(NotificationsContext).toggleNotification;
const RBACContext = React.createContext({});
const RBACProviderContext = RBACContext;
const useRBAC$1 = () => React.useContext(RBACContext);
const useRBACProvider = useRBAC$1;
var objectProto$c = Object.prototype;
function isPrototype$2(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$c;
  return value === proto;
}
var _isPrototype = isPrototype$2;
function overArg$2(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$1 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function baseKeys$2(object) {
  if (!isPrototype$1(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$9.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$2;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$8 = freeGlobal || freeSelf || Function("return this")();
var _root = root$8;
var root$7 = _root;
var Symbol$5 = root$7.Symbol;
var _Symbol = Symbol$5;
var Symbol$4 = _Symbol;
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
var nativeObjectToString$1 = objectProto$a.toString;
var symToStringTag$1 = Symbol$4 ? Symbol$4.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$9 = Object.prototype;
var nativeObjectToString = objectProto$9.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$3 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : void 0;
function baseGetTag$5(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$5;
function isObject$6(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$6;
const isObject$7 = /* @__PURE__ */ getDefaultExportFromCjs(isObject_1);
var baseGetTag$4 = _baseGetTag, isObject$5 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$5(value)) {
    return false;
  }
  var tag = baseGetTag$4(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
var root$6 = _root;
var coreJsData$1 = root$6["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1, isMasked = _isMasked, isObject$4 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$8 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$4(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$6(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$6;
var getNative$5 = _getNative, root$5 = _root;
var DataView$1 = getNative$5(root$5, "DataView");
var _DataView = DataView$1;
var getNative$4 = _getNative, root$4 = _root;
var Map$4 = getNative$4(root$4, "Map");
var _Map = Map$4;
var getNative$3 = _getNative, root$3 = _root;
var Promise$2 = getNative$3(root$3, "Promise");
var _Promise = Promise$2;
var getNative$2 = _getNative, root$2 = _root;
var Set$1 = getNative$2(root$2, "Set");
var _Set = Set$1;
var getNative$1 = _getNative, root$1 = _root;
var WeakMap$2 = getNative$1(root$1, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView, Map$3 = _Map, Promise$1 = _Promise, Set = _Set, WeakMap$1 = _WeakMap, baseGetTag$3 = _baseGetTag, toSource = _toSource;
var mapTag$3 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$3), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap$1);
var getTag$2 = baseGetTag$3;
if (DataView && getTag$2(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$3 && getTag$2(new Map$3()) != mapTag$3 || Promise$1 && getTag$2(Promise$1.resolve()) != promiseTag || Set && getTag$2(new Set()) != setTag$3 || WeakMap$1 && getTag$2(new WeakMap$1()) != weakMapTag$1) {
  getTag$2 = function(value) {
    var result = baseGetTag$3(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$2;
function isObjectLike$5(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$5;
var baseGetTag$2 = _baseGetTag, isObjectLike$4 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$4(value) && baseGetTag$2(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$3 = isObjectLike_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments$3 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$3(value) && hasOwnProperty$6.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$3;
var isArray$a = Array.isArray;
var isArray_1 = isArray$a;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$3;
var isFunction$1 = isFunction_1, isLength$2 = isLength_1;
function isArrayLike$2(value) {
  return value != null && isLength$2(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$2;
var isBuffer$4 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
isBuffer$4.exports;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$4, isBuffer$4.exports);
var isBufferExports = isBuffer$4.exports;
var baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$2 = isObjectLike_1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$2(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$4 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$4;
var baseKeys$1 = _baseKeys, getTag$1 = _getTag, isArguments$2 = isArguments_1, isArray$9 = isArray_1, isArrayLike$1 = isArrayLike_1, isBuffer$3 = isBufferExports, isPrototype = _isPrototype, isTypedArray$3 = isTypedArray_1;
var mapTag$1 = "[object Map]", setTag$1 = "[object Set]";
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike$1(value) && (isArray$9(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer$3(value) || isTypedArray$3(value) || isArguments$2(value))) {
    return !value.length;
  }
  var tag = getTag$1(value);
  if (tag == mapTag$1 || tag == setTag$1) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys$1(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty$5.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_1 = isEmpty;
const isEmpty$1 = /* @__PURE__ */ getDefaultExportFromCjs(isEmpty_1);
function isNil(value) {
  return value == null;
}
var isNil_1 = isNil;
const isNil$1 = /* @__PURE__ */ getDefaultExportFromCjs(isNil_1);
const TOKEN_KEY = "jwtToken";
const USER_INFO = "userInfo";
const CURRENT_STEP = "GUIDED_TOUR_CURRENT_STEP";
const COMPLETED_STEPS = "GUIDED_TOUR_COMPLETED_STEPS";
const SKIPPED = "GUIDED_TOUR_SKIPPED";
const THEME_KEY = "STRAPI_THEME";
const UPLOAD_MODAL_VIEW = "STRAPI_UPLOAD_MODAL_VIEW";
const UPLOAD_VIEW = "STRAPI_UPLOAD_LIBRARY_VIEW";
const parse = JSON.parse;
const stringify = JSON.stringify;
const auth = {
  clear(key) {
    if (localStorage.getItem(key)) {
      return localStorage.removeItem(key);
    }
    if (sessionStorage.getItem(key)) {
      return sessionStorage.removeItem(key);
    }
    return null;
  },
  clearAppStorage() {
    if (localStorage) {
      const videos = auth.get("videos");
      const onboarding = auth.get("onboarding");
      const strapiUpdateNotification = auth.get("STRAPI_UPDATE_NOTIF");
      const localeLang = localStorage.getItem("strapi-admin-language");
      const guidedTourCurrentStep = auth.get(CURRENT_STEP);
      const guidedTourState = auth.get(COMPLETED_STEPS);
      const guidedTourSkipped = auth.get(SKIPPED);
      const applicationTheme = auth.get(THEME_KEY);
      const uploadMediaLibraryView = auth.get(UPLOAD_VIEW);
      const uploadMediaLibraryModalView = auth.get(UPLOAD_MODAL_VIEW);
      localStorage.clear();
      localStorage.setItem("videos", stringify(videos));
      localStorage.setItem(CURRENT_STEP, stringify(guidedTourCurrentStep));
      localStorage.setItem(COMPLETED_STEPS, stringify(guidedTourState));
      localStorage.setItem(SKIPPED, stringify(guidedTourSkipped));
      localStorage.setItem("STRAPI_UPDATE_NOTIF", stringify(strapiUpdateNotification));
      if (onboarding) {
        localStorage.setItem("onboarding", stringify(onboarding));
      }
      if (localeLang) {
        localStorage.setItem("strapi-admin-language", localeLang);
      }
      if (applicationTheme) {
        localStorage.setItem(THEME_KEY, applicationTheme);
      }
      if (!isNil$1(uploadMediaLibraryView)) {
        localStorage.setItem(UPLOAD_VIEW, stringify(uploadMediaLibraryView));
      }
      if (!isNil$1(uploadMediaLibraryModalView)) {
        localStorage.setItem(UPLOAD_MODAL_VIEW, stringify(uploadMediaLibraryModalView));
      }
    }
    sessionStorage.clear();
  },
  get(key) {
    const localStorageItem = localStorage.getItem(key);
    if (localStorageItem) {
      try {
        const parsedItem = parse(localStorageItem);
        return parsedItem;
      } catch (error) {
        return localStorageItem;
      }
    }
    const sessionStorageItem = sessionStorage.getItem(key);
    if (sessionStorageItem) {
      try {
        const parsedItem = parse(sessionStorageItem);
        return parsedItem;
      } catch (error) {
        return sessionStorageItem;
      }
    }
    return null;
  },
  set(value, key, isLocalStorage) {
    if (isEmpty$1(value)) {
      return null;
    }
    if (isLocalStorage) {
      return localStorage.setItem(key, stringify(value));
    }
    return sessionStorage.setItem(key, stringify(value));
  },
  /**
   * @deprecated use auth.clear("jwtToken") instead
   */
  clearToken(tokenKey = TOKEN_KEY) {
    void auth.clear(tokenKey);
  },
  /**
   * @deprecated use auth.clear("userInfo") instead
   */
  clearUserInfo(userInfoKey = USER_INFO) {
    return auth.clear(userInfoKey);
  },
  /**
   * @deprecated use auth.get("jwtToken") instead
   */
  getToken(tokenKey = TOKEN_KEY) {
    return auth.get(tokenKey);
  },
  /**
   * @deprecated use auth.get("userInfo") instead
   */
  getUserInfo(userInfoKey = USER_INFO) {
    return auth.get(userInfoKey);
  },
  /**
   * @depreacted use auth.set(value, "jwtToken", true | false) instead
   */
  setToken(value = "", isLocalStorage = false, tokenKey = TOKEN_KEY) {
    void auth.set(value, tokenKey, isLocalStorage);
  },
  /**
   * @depreacted use auth.set(value, "userInfo", true | false) instead
   */
  setUserInfo(value, isLocalStorage = false, userInfo = USER_INFO) {
    void auth.set(value, userInfo, isLocalStorage);
  },
  /**
   * @depreacted use auth.set(value, "userInfo", true | false) instead
   */
  updateToken(value = "") {
    const isLocalStorage = Boolean(localStorage.getItem(TOKEN_KEY));
    void auth.setToken(value, isLocalStorage);
  }
};
const fetchClient = () => {
  const instance2 = axios.create({
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    paramsSerializer: (params) => {
      return qs.stringify(params, { encode: false });
    }
  });
  instance2.interceptors.request.use(
    async (config) => {
      config.headers.Authorization = `Bearer ${auth.getToken()}`;
      return config;
    },
    (error) => Promise.reject(error)
  );
  instance2.interceptors.response.use(
    (response) => response,
    (error) => {
      var _a;
      if (((_a = error == null ? void 0 : error.response) == null ? void 0 : _a.status) === 401) {
        auth.clearAppStorage();
        window.location.reload();
      }
      throw error;
    }
  );
  return instance2;
};
const instance = fetchClient();
const addPrependingSlash = (url) => url.charAt(0) !== "/" ? `/${url}` : url;
const hasProtocol = (url) => new RegExp("^(?:[a-z+]+:)?//", "i").test(url);
const normalizeUrl = (url) => hasProtocol(url) ? url : addPrependingSlash(url);
const getFetchClient = (defaultOptions = {}) => {
  instance.defaults.baseURL = window.strapi.backendURL;
  return {
    get: (url, config) => instance.get(normalizeUrl(url), {
      ...defaultOptions,
      ...config
    }),
    put: (url, data, config) => instance.put(normalizeUrl(url), data, { ...defaultOptions, ...config }),
    post: (url, data, config) => instance.post(normalizeUrl(url), data, { ...defaultOptions, ...config }),
    del: (url, config) => instance.delete(normalizeUrl(url), { ...defaultOptions, ...config })
  };
};
const findMatchingPermissions = (userPermissions, permissions) => userPermissions.reduce((acc, curr) => {
  const associatedPermission = permissions.find(
    (perm) => perm.action === curr.action && perm.subject === curr.subject
  );
  if (associatedPermission) {
    acc.push(curr);
  }
  return acc;
}, []);
const formatPermissionsForRequest = (permissions) => permissions.map((permission) => {
  if (!permission.action) {
    return {};
  }
  const returnedPermission = {
    action: permission.action
  };
  if (permission.subject) {
    returnedPermission.subject = permission.subject;
  }
  return returnedPermission;
});
const shouldCheckPermissions = (permissions) => permissions.length > 0 && permissions.every((perm) => Array.isArray(perm.conditions) && perm.conditions.length > 0);
const hasPermissions = async (userPermissions, permissions, signal) => {
  if (!permissions || !permissions.length) {
    return true;
  }
  const matchingPermissions = findMatchingPermissions(userPermissions, permissions);
  if (shouldCheckPermissions(matchingPermissions)) {
    let hasPermission = false;
    try {
      const {
        data: { data }
      } = await getFetchClient().post(
        "/admin/permissions/check",
        {
          permissions: formatPermissionsForRequest(matchingPermissions)
        },
        { signal }
      );
      hasPermission = data.every((v) => v === true);
    } catch (err) {
      console.error("Error while checking permissions", err);
    }
    return hasPermission;
  }
  return matchingPermissions.length > 0;
};
const Wrapper = styled(Flex$1)`
  height: 100vh;
`;
const LoadingIndicatorPage = ({
  children = "Loading content.",
  "data-testid": dataTestId = "loader"
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Wrapper, { justifyContent: "space-around", "data-testid": dataTestId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Loader, { children }) });
};
const CheckPagePermissions = ({ permissions = [], children }) => {
  const abortController = new AbortController();
  const { signal } = abortController;
  const { allPermissions } = useRBACProvider();
  const toggleNotification = useNotification();
  const [state, setState] = React.useState({ isLoading: true, canAccess: false });
  const isMounted = React.useRef(true);
  React.useEffect(() => {
    const checkPermission = async () => {
      try {
        setState({ isLoading: true, canAccess: false });
        const canAccess = await hasPermissions(allPermissions || [], permissions, signal);
        if (isMounted.current) {
          setState({ isLoading: false, canAccess });
        }
      } catch (err) {
        if (isMounted.current) {
          console.error(err);
          toggleNotification == null ? void 0 : toggleNotification({
            type: "warning",
            message: { id: "notification.error" }
          });
          setState({ isLoading: false, canAccess: false });
        }
      }
    };
    checkPermission();
    return () => {
      abortController.abort();
    };
  }, [permissions]);
  React.useEffect(() => {
    return () => {
      isMounted.current = false;
    };
  }, []);
  if (state.isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingIndicatorPage, {});
  }
  if (!state.canAccess) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Redirect, { to: "/" });
  }
  return children;
};
const CheckPermissions = ({ permissions = [], children }) => {
  const { allPermissions } = useRBACProvider();
  const toggleNotification = useNotification();
  const [state, setState] = React.useState({ isLoading: true, canAccess: false });
  const isMounted = React.useRef(true);
  const abortController = new AbortController();
  const { signal } = abortController;
  React.useEffect(() => {
    const checkPermission = async () => {
      try {
        setState({ isLoading: true, canAccess: false });
        const canAccess = await hasPermissions(allPermissions || [], permissions, signal);
        if (isMounted.current) {
          setState({ isLoading: false, canAccess });
        }
      } catch (err) {
        if (isMounted.current) {
          console.error(err);
          toggleNotification == null ? void 0 : toggleNotification({
            type: "warning",
            message: { id: "notification.error" }
          });
          setState({ isLoading: false, canAccess: false });
        }
      }
    };
    checkPermission();
    return () => {
      abortController.abort();
    };
  }, [permissions]);
  React.useEffect(() => {
    return () => {
      isMounted.current = false;
    };
  }, []);
  if (state.isLoading) {
    return null;
  }
  if (!state.canAccess) {
    return null;
  }
  return children;
};
const Root$1 = ({
  children,
  iconRightButton,
  isConfirmButtonLoading = false,
  isOpen,
  onConfirm,
  onToggleDialog,
  leftButtonText = {
    id: "app.components.Button.cancel",
    defaultMessage: "Cancel"
  },
  rightButtonText = {
    id: "app.components.Button.confirm",
    defaultMessage: "Confirm"
  },
  title = {
    id: "app.components.ConfirmDialog.title",
    defaultMessage: "Confirmation"
  },
  variantRightButton = "danger-light",
  ...props
}) => {
  const { formatMessage } = useIntl();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      onClose: onToggleDialog,
      title: formatMessage({
        id: title.id,
        defaultMessage: title.defaultMessage
      }),
      isOpen,
      id: "confirmation",
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { id: "confirm-description", children }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Footer,
          {
            iconRightButton,
            isConfirmButtonLoading,
            leftButtonText,
            onConfirm,
            onToggleDialog,
            rightButtonText,
            variantRightButton
          }
        )
      ]
    }
  );
};
const Body$1 = ({ iconBody = /* @__PURE__ */ jsxRuntimeExports.jsx(ExclamationMarkCircle, {}), children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogBody, { icon: iconBody, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Flex$1, { direction: "column", alignItems: "stretch", gap: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Flex$1, { justifyContent: "center", children }) }) });
};
const Footer = ({
  iconRightButton = /* @__PURE__ */ jsxRuntimeExports.jsx(Trash, {}),
  isConfirmButtonLoading,
  leftButtonText,
  onConfirm,
  onToggleDialog,
  rightButtonText,
  variantRightButton
}) => {
  const { formatMessage } = useIntl();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogFooter,
    {
      startAction: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onToggleDialog, variant: "tertiary", children: formatMessage({
        id: leftButtonText.id,
        defaultMessage: leftButtonText.defaultMessage
      }) }),
      endAction: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          onClick: onConfirm,
          variant: variantRightButton,
          startIcon: iconRightButton,
          id: "confirm-delete",
          loading: isConfirmButtonLoading,
          children: formatMessage({
            id: rightButtonText.id,
            defaultMessage: rightButtonText.defaultMessage
          })
        }
      )
    }
  );
};
const ConfirmDialog = ({
  bodyText = {
    id: "components.popUpWarning.message",
    defaultMessage: "Are you sure you want to delete this?"
  },
  ...props
}) => {
  const { formatMessage } = useIntl();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root$1, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Body$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "omega", children: formatMessage({
    id: bodyText.id,
    defaultMessage: bodyText.defaultMessage
  }) }) }) });
};
ConfirmDialog.Root = Root$1;
ConfirmDialog.Body = Body$1;
const IconWrapper = styled(Flex$1)`
  margin-right: ${({ theme }) => theme.spaces[6]};

  svg {
    width: ${32 / 16}rem;
    height: ${32 / 16}rem;
  }
`;
const TypographyWordBreak = styled(Typography$1)`
  word-break: break-all;
`;
const ContentBox = ({
  title,
  subtitle,
  icon,
  iconBackground,
  endAction,
  titleEllipsis = false
}) => {
  if (title && title.length > 70 && titleEllipsis) {
    title = `${title.substring(0, 70)}...`;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex$1, { shadow: "tableShadow", hasRadius: true, padding: 6, background: "neutral0", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(IconWrapper, { background: iconBackground, hasRadius: true, padding: 3, children: icon }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex$1, { direction: "column", alignItems: "stretch", gap: endAction ? 0 : 1, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyWordBreak, { fontWeight: "semiBold", variant: "pi", children: title }),
        endAction
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textColor: "neutral600", children: subtitle })
    ] })
  ] });
};
const PREFIX = "[@strapi/helper-plugin]:";
const once = (fn) => {
  const func = fn;
  let called = false;
  if (typeof func !== "function") {
    throw new TypeError(`${PREFIX} once requires a function parameter`);
  }
  return (...args) => {
    if (!called) {
      func(...args);
      called = true;
    }
  };
};
const warnOnce$1 = once(console.warn);
const DateTimePickerLegacy = (props) => {
  warnOnce$1(
    `
      Deprecation warning: Usage of "DateTimePicker" component from the helper-plugin is deprecated and will be removed in the next major release. Instead, use the DateTimePicker from the Design System: import { DateTimePicker } from '@strapi/design-system';"
    `
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimePicker, { ...props });
};
const AppInfoContext = React.createContext({});
const AppInfoProvider = ({
  children,
  autoReload,
  communityEdition,
  currentEnvironment,
  dependencies,
  latestStrapiReleaseTag,
  nodeVersion,
  projectId,
  setUserDisplayName,
  shouldUpdateStrapi,
  strapiVersion,
  useYarn,
  userDisplayName,
  userId
}) => {
  const contextValue = React.useMemo(
    () => ({
      autoReload,
      communityEdition,
      currentEnvironment,
      dependencies,
      latestStrapiReleaseTag,
      nodeVersion,
      projectId,
      setUserDisplayName,
      shouldUpdateStrapi,
      strapiVersion,
      useYarn,
      userDisplayName,
      userId
    }),
    [
      autoReload,
      communityEdition,
      currentEnvironment,
      dependencies,
      latestStrapiReleaseTag,
      nodeVersion,
      projectId,
      setUserDisplayName,
      shouldUpdateStrapi,
      strapiVersion,
      useYarn,
      userDisplayName,
      userId
    ]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AppInfoContext.Provider, { value: contextValue, children });
};
const useAppInfo = () => React.useContext(AppInfoContext);
/**
 * @preserve
 * @deprecated use useAppInfo instead
 */
const useAppInfos = useAppInfo;
/**
 * @preserve
 * @deprecated use AppInfoProvider instead
 */
const AppInfosProvider = AppInfoProvider;
/**
 * @preserve
 * @deprecated use AppInfoContext instead
 */
const AppInfosContext = AppInfoContext;
const TrackingContext = React.createContext({
  uuid: false
});
const TrackingProvider = ({ value = { uuid: false }, children }) => {
  const memoizedValue = React.useMemo(() => value, [value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TrackingContext.Provider, { value: memoizedValue, children });
};
const useTracking = () => {
  const { uuid, telemetryProperties, deviceId } = React.useContext(TrackingContext);
  const appInfo = useAppInfo();
  const userId = appInfo == null ? void 0 : appInfo.userId;
  const trackUsage = React.useCallback(
    async (event, properties) => {
      try {
        if (uuid && !window.strapi.telemetryDisabled) {
          const res = await axios.post(
            "https://analytics.strapi.io/api/v2/track",
            {
              event,
              userId,
              deviceId,
              eventProperties: { ...properties },
              userProperties: {},
              groupProperties: {
                ...telemetryProperties,
                projectId: uuid,
                projectType: window.strapi.projectType
              }
            },
            {
              headers: {
                "Content-Type": "application/json",
                "X-Strapi-Event": event
              }
            }
          );
          return res;
        }
      } catch (err) {
      }
      return null;
    },
    [deviceId, telemetryProperties, userId, uuid]
  );
  return { trackUsage };
};
const useQueryParams = (initialParams) => {
  const { search } = useLocation();
  const { push } = useHistory();
  const query = useMemo(() => {
    const searchQuery = search.substring(1);
    if (!search) {
      return initialParams;
    }
    return parse$1(searchQuery);
  }, [search, initialParams]);
  const setQuery = useCallback(
    (nextParams, method = "push") => {
      let nextQuery = { ...query };
      if (method === "remove") {
        Object.keys(nextParams).forEach((key) => {
          if (Object.prototype.hasOwnProperty.call(nextQuery, key)) {
            delete nextQuery[key];
          }
        });
      } else {
        nextQuery = { ...query, ...nextParams };
      }
      push({ search: stringify$1(nextQuery, { encode: false }) });
    },
    [push, query]
  );
  return [{ query, rawQuery: search }, setQuery];
};
const transientProps = {
  isUp: true
};
const SortIcon = styled(CarretDown).withConfig({
  shouldForwardProp: (prop, defPropValFN) => !transientProps[prop] && defPropValFN(prop)
})`
  transform: ${({ isUp = false }) => `rotate(${isUp ? "180" : "0"}deg)`};
`;
const icons = {
  document: EmptyDocuments,
  media: EmptyPictures,
  permissions: EmptyPermissions
};
const EmptyStateLayout = ({
  action,
  content = {
    id: "app.components.EmptyStateLayout.content-document",
    defaultMessage: "No content found"
  },
  hasRadius = true,
  icon = "document",
  shadow = "tableShadow"
}) => {
  const Icon2 = icons[icon];
  const { formatMessage } = useIntl();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    EmptyStateLayout$1,
    {
      action,
      content: formatMessage(
        { id: content.id, defaultMessage: content.defaultMessage },
        content.values
      ),
      hasRadius,
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { width: "10rem" }),
      shadow
    }
  );
};
const EmptyBodyTable = ({ colSpan, isLoading = false, ...rest }) => {
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Tbody, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tr, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Td, { colSpan, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Flex$1, { justifyContent: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { padding: 11, background: "neutral0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Loader, { children: "Loading content..." }) }) }) }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tbody, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tr, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Td, { colSpan, children: /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyStateLayout, { ...rest, hasRadius: false }) }) }) });
};
const Table$1 = ({
  action,
  children,
  contentType,
  components: components2,
  footer,
  headers = [],
  isLoading = false,
  onConfirmDeleteAll,
  onConfirmDelete,
  rows = [],
  withBulkActions = false,
  withMainAction = false,
  renderBulkActionsBar,
  ...rest
}) => {
  const [selectedEntries, setSelectedEntries] = React.useState([]);
  const [showConfirmDeleteAll, setShowConfirmDeleteAll] = React.useState(false);
  const [showConfirmDelete, setShowConfirmDelete] = React.useState(false);
  const [isConfirmButtonLoading, setIsConfirmButtonLoading] = React.useState(false);
  const [{ query }] = useQueryParams();
  const { formatMessage } = useIntl();
  const { trackUsage } = useTracking();
  const ROW_COUNT = rows.length + 1;
  const COL_COUNT = headers.length + (withBulkActions ? 1 : 0) + (withMainAction ? 1 : 0);
  const hasFilters = (query == null ? void 0 : query.filters) !== void 0;
  const areAllEntriesSelected = selectedEntries.length === rows.length && rows.length > 0;
  const content = hasFilters ? {
    id: "content-manager.components.TableEmpty.withFilters",
    defaultMessage: "There are no {contentType} with the applied filters...",
    values: { contentType }
  } : void 0;
  const handleConfirmDeleteAll = async () => {
    try {
      setIsConfirmButtonLoading(true);
      await (onConfirmDeleteAll == null ? void 0 : onConfirmDeleteAll(selectedEntries));
      handleToggleConfirmDeleteAll();
      setSelectedEntries([]);
      setIsConfirmButtonLoading(false);
    } catch (err) {
      setIsConfirmButtonLoading(false);
      handleToggleConfirmDeleteAll();
    }
  };
  const handleConfirmDelete = async () => {
    try {
      setIsConfirmButtonLoading(true);
      await (onConfirmDelete == null ? void 0 : onConfirmDelete(selectedEntries[0]));
      handleToggleConfirmDelete();
      setIsConfirmButtonLoading(false);
    } catch (err) {
      setIsConfirmButtonLoading(false);
      handleToggleConfirmDelete();
    }
  };
  const handleSelectAll = () => {
    if (!areAllEntriesSelected) {
      setSelectedEntries(rows.map((row) => row.id));
    } else {
      setSelectedEntries([]);
    }
  };
  const handleToggleConfirmDeleteAll = () => {
    if (!showConfirmDeleteAll) {
      trackUsage("willBulkDeleteEntries");
    }
    setShowConfirmDeleteAll((prev) => !prev);
  };
  const handleToggleConfirmDelete = () => {
    if (showConfirmDelete) {
      setSelectedEntries([]);
    }
    setShowConfirmDelete((prev) => !prev);
  };
  const handleClickDelete = (id) => {
    setSelectedEntries([id]);
    handleToggleConfirmDelete();
  };
  const handleSelectRow = ({ name, value }) => {
    setSelectedEntries((prev) => {
      if (value) {
        return prev.concat(name);
      }
      return prev.filter((id) => id !== name);
    });
  };
  const clearSelectedEntries = () => {
    setSelectedEntries([]);
  };
  const ConfirmDeleteAllComponent = (components2 == null ? void 0 : components2.ConfirmDialogDeleteAll) ? components2.ConfirmDialogDeleteAll : ConfirmDialog;
  const ConfirmDeleteComponent = (components2 == null ? void 0 : components2.ConfirmDialogDelete) ? components2.ConfirmDialogDelete : ConfirmDialog;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    selectedEntries.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex$1, { gap: 3, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "omega", textColor: "neutral500", children: formatMessage(
        {
          id: "content-manager.components.TableDelete.label",
          defaultMessage: "{number, plural, one {# entry} other {# entries}} selected"
        },
        { number: selectedEntries.length }
      ) }),
      renderBulkActionsBar ? renderBulkActionsBar({ selectedEntries, clearSelectedEntries }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          onClick: handleToggleConfirmDeleteAll,
          startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash, {}),
          size: "L",
          variant: "danger-light",
          children: formatMessage({ id: "global.delete", defaultMessage: "Delete" })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Table$2, { colCount: COL_COUNT, rowCount: ROW_COUNT, footer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TableHead,
        {
          areAllEntriesSelected,
          entriesToDelete: selectedEntries,
          headers,
          onSelectAll: handleSelectAll,
          withMainAction,
          withBulkActions
        }
      ),
      !rows.length || isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        EmptyBodyTable,
        {
          colSpan: COL_COUNT,
          content,
          isLoading,
          action
        }
      ) : React.Children.toArray(children).map(
        (child) => React.cloneElement(child, {
          entriesToDelete: selectedEntries,
          onClickDelete: handleClickDelete,
          onSelectRow: handleSelectRow,
          headers,
          rows,
          withBulkActions,
          withMainAction,
          ...rest
        })
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ConfirmDeleteAllComponent,
      {
        isConfirmButtonLoading,
        onConfirm: handleConfirmDeleteAll,
        onToggleDialog: handleToggleConfirmDeleteAll,
        isOpen: showConfirmDeleteAll
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ConfirmDeleteComponent,
      {
        isConfirmButtonLoading,
        onConfirm: handleConfirmDelete,
        onToggleDialog: handleToggleConfirmDelete,
        isOpen: showConfirmDelete
      }
    )
  ] });
};
const TableHead = ({
  areAllEntriesSelected = false,
  entriesToDelete = [],
  headers = [],
  onSelectAll,
  withMainAction,
  withBulkActions
}) => {
  const { formatMessage } = useIntl();
  const [{ query }, setQuery] = useQueryParams();
  const sort = typeof (query == null ? void 0 : query.sort) === "string" ? query.sort : "";
  const [sortBy, sortOrder] = sort.split(":");
  const isIndeterminate = !areAllEntriesSelected && entriesToDelete.length > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Thead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tr, { children: [
    withMainAction && /* @__PURE__ */ jsxRuntimeExports.jsx(Th, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      BaseCheckbox,
      {
        "aria-label": formatMessage({
          id: "global.select-all-entries",
          defaultMessage: "Select all entries"
        }),
        checked: areAllEntriesSelected,
        indeterminate: isIndeterminate,
        onChange: onSelectAll
      }
    ) }),
    headers.map(
      ({ fieldSchema, name, metadatas: { sortable: isSortable, label, mainField } }) => {
        let isSorted = sortBy === name;
        const isUp = sortOrder === "ASC";
        if ((fieldSchema == null ? void 0 : fieldSchema.type) === "relation" && mainField) {
          isSorted = sortBy === `${name.split(".")[0]}[${mainField.name}]`;
        }
        const sortLabel = formatMessage(
          { id: "components.TableHeader.sort", defaultMessage: "Sort on {label}" },
          { label }
        );
        const handleClickSort = (shouldAllowClick = true) => {
          if (isSortable && shouldAllowClick) {
            let nextSort = name;
            if ((fieldSchema == null ? void 0 : fieldSchema.type) === "relation" && mainField) {
              nextSort = `${name.split(".")[0]}[${mainField.name}]`;
            }
            setQuery({
              sort: `${nextSort}:${isSorted && sortOrder === "ASC" ? "DESC" : "ASC"}`
            });
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Th,
          {
            action: isSorted && /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                label: sortLabel,
                onClick: () => handleClickSort(),
                icon: isSorted && /* @__PURE__ */ jsxRuntimeExports.jsx(SortIcon, { isUp }),
                noBorder: true
              }
            ),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { label: isSortable ? sortLabel : label, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography$1,
              {
                as: !isSorted && isSortable ? "button" : "span",
                textColor: "neutral600",
                onClick: () => handleClickSort(!isSorted),
                variant: "sigma",
                children: label
              }
            ) })
          },
          name
        );
      }
    ),
    withBulkActions && /* @__PURE__ */ jsxRuntimeExports.jsx(Th, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { children: formatMessage({
      id: "global.actions",
      defaultMessage: "Actions"
    }) }) })
  ] }) });
};
const TableContext = React.createContext(null);
const useTableContext = () => {
  const context = React.useContext(TableContext);
  if (!context) {
    throw new Error("useTableContext must be used within a TableProvider");
  }
  return context;
};
const ActionBar = ({ children }) => {
  const { formatMessage } = useIntl();
  const { selectedEntries } = useTableContext();
  if (selectedEntries.length === 0)
    return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex$1, { gap: 2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "omega", textColor: "neutral500", children: formatMessage(
      {
        id: "content-manager.components.TableDelete.label",
        defaultMessage: "{number, plural, one {# entry} other {# entries}} selected"
      },
      { number: selectedEntries.length }
    ) }),
    children
  ] });
};
const BulkDeleteButton = ({ onConfirmDeleteAll }) => {
  const { selectedEntries, setSelectedEntries } = useTableContext();
  const { formatMessage } = useIntl();
  const [showConfirmDeleteAll, setShowConfirmDeleteAll] = React.useState(false);
  const [isConfirmButtonLoading, setIsConfirmButtonLoading] = React.useState(false);
  const handleConfirmDeleteAll = async () => {
    try {
      setIsConfirmButtonLoading(true);
      await onConfirmDeleteAll(selectedEntries);
      setIsConfirmButtonLoading(false);
      handleToggleConfirmDeleteAll();
      setSelectedEntries([]);
    } catch (err) {
      setIsConfirmButtonLoading(false);
      handleToggleConfirmDeleteAll();
    }
  };
  const handleToggleConfirmDeleteAll = () => {
    setShowConfirmDeleteAll((prev) => !prev);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: handleToggleConfirmDeleteAll,
        startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash, {}),
        size: "L",
        variant: "danger-light",
        children: formatMessage({ id: "global.delete", defaultMessage: "Delete" })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ConfirmDialog,
      {
        isConfirmButtonLoading,
        onConfirm: handleConfirmDeleteAll,
        onToggleDialog: handleToggleConfirmDeleteAll,
        isOpen: showConfirmDeleteAll
      }
    )
  ] });
};
const Head = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Thead, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tr, { children }) });
};
const HeaderCheckboxCell = () => {
  const { selectedEntries, setSelectedEntries, rows } = useTableContext();
  const { formatMessage } = useIntl();
  const areAllEntriesSelected = selectedEntries.length === rows.length && rows.length > 0;
  const isIndeterminate = !areAllEntriesSelected && selectedEntries.length > 0;
  const handleSelectAll = () => {
    if (!areAllEntriesSelected) {
      setSelectedEntries(rows.map((row) => row.id));
    } else {
      setSelectedEntries([]);
    }
  };
  if (rows.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Th, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    BaseCheckbox,
    {
      "aria-label": formatMessage({
        id: "global.select-all-entries",
        defaultMessage: "Select all entries"
      }),
      checked: areAllEntriesSelected,
      indeterminate: isIndeterminate,
      onChange: handleSelectAll
    }
  ) });
};
const HeaderHiddenActionsCell = () => {
  const { formatMessage } = useIntl();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Th, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { children: formatMessage({
    id: "global.actions",
    defaultMessage: "Actions"
  }) }) });
};
const HeaderCell = ({
  fieldSchemaType,
  name,
  relationFieldName,
  isSortable,
  label
}) => {
  const [{ query }, setQuery] = useQueryParams();
  const sort = typeof (query == null ? void 0 : query.sort) === "string" ? query.sort : "";
  const [sortBy, sortOrder] = sort.split(":");
  const { formatMessage } = useIntl();
  let isSorted = sortBy === name;
  const isUp = sortOrder === "ASC";
  if (fieldSchemaType === "relation" && relationFieldName) {
    isSorted = sortBy === `${name.split(".")[0]}[${relationFieldName}]`;
  }
  const sortLabel = formatMessage(
    { id: "components.TableHeader.sort", defaultMessage: "Sort on {label}" },
    { label }
  );
  const handleClickSort = (shouldAllowClick = true) => {
    if (isSortable && shouldAllowClick) {
      let nextSort = name;
      if (fieldSchemaType === "relation" && relationFieldName) {
        nextSort = `${name.split(".")[0]}[${relationFieldName}]`;
      }
      setQuery({
        sort: `${nextSort}:${isSorted && sortOrder === "ASC" ? "DESC" : "ASC"}`
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Th,
    {
      action: isSorted && isSortable && /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          label: sortLabel,
          onClick: () => handleClickSort(true),
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SortIcon, { isUp }),
          noBorder: true
        }
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { label: isSortable ? sortLabel : label, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography$1,
        {
          textColor: "neutral600",
          as: !isSorted && isSortable ? "button" : "span",
          onClick: () => handleClickSort(),
          variant: "sigma",
          children: label
        }
      ) })
    },
    name
  );
};
const Root = ({
  children,
  defaultSelectedEntries = [],
  rows = [],
  colCount = 0,
  isLoading,
  isFetching
}) => {
  const [selectedEntries, setSelectedEntries] = React.useState(defaultSelectedEntries);
  const rowCount = rows.length + 1;
  const onSelectRow = React.useCallback(({ name, value }) => {
    setSelectedEntries((prev) => {
      if (value) {
        return prev.concat(name);
      }
      return prev.filter((id) => id !== name);
    });
  }, []);
  const context = React.useMemo(() => {
    return {
      selectedEntries,
      setSelectedEntries,
      onSelectRow,
      rows,
      isLoading,
      isFetching,
      colCount,
      rowCount
    };
  }, [
    onSelectRow,
    selectedEntries,
    setSelectedEntries,
    rows,
    isLoading,
    isFetching,
    colCount,
    rowCount
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContext.Provider, { value: context, children });
};
const EmptyBody = ({ contentType, ...rest }) => {
  const { rows, colCount, isLoading } = useTableContext();
  const [{ query }] = useQueryParams();
  const hasFilters = (query == null ? void 0 : query.filters) !== void 0;
  const content = hasFilters ? {
    id: "content-manager.components.TableEmpty.withFilters",
    defaultMessage: "There are no {contentType} with the applied filters...",
    values: { contentType }
  } : void 0;
  if ((rows == null ? void 0 : rows.length) > 0 || isLoading) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tbody, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tr, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Td, { colSpan: colCount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyStateLayout, { ...rest, content, hasRadius: false, shadow: void 0 }) }) }) });
};
const LoadingBody = () => {
  const { isLoading, colCount } = useTableContext();
  if (!isLoading) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tbody, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tr, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Td, { colSpan: colCount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Flex$1, { justifyContent: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { padding: 11, background: "neutral0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Loader, { children: "Loading content" }) }) }) }) }) });
};
const Body = ({ children }) => {
  const { rows, isLoading } = useTableContext();
  if (isLoading || rows.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tbody, { children });
};
const Content = ({ children, footer }) => {
  const { rowCount, colCount } = useTableContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Table$2, { rowCount, colCount, footer, children });
};
const Table = {
  Content,
  Root,
  Body,
  ActionBar,
  Head,
  HeaderCell,
  HeaderHiddenActionsCell,
  HeaderCheckboxCell,
  LoadingBody,
  EmptyBody,
  BulkDeleteButton
};
const FilterListURLQuery = ({ filtersSchema = [] }) => {
  var _a, _b, _c, _d;
  const [{ query }, setQuery] = useQueryParams();
  const handleClick = (filter) => {
    var _a2;
    const nextFilters = (((_a2 = query == null ? void 0 : query.filters) == null ? void 0 : _a2.$and) || []).filter((prevFilter) => {
      var _a3;
      const name = Object.keys(filter)[0];
      const filterType = Object.keys(filter[name])[0];
      const value = filter[name][filterType];
      return ((_a3 = prevFilter[name]) == null ? void 0 : _a3[filterType]) !== value;
    });
    setQuery({ filters: { $and: nextFilters }, page: 1 });
  };
  if (!((_b = (_a = query == null ? void 0 : query.filters) == null ? void 0 : _a.$and) == null ? void 0 : _b.length)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: (_d = (_c = query == null ? void 0 : query.filters) == null ? void 0 : _c.$and) == null ? void 0 : _d.map((filter, i) => {
    var _a2, _b2;
    const attributeName = Object.keys(filter)[0];
    const attribute = filtersSchema.find(({ name }) => name === attributeName);
    if (!attribute) {
      return null;
    }
    if (attribute.fieldSchema.type === "relation") {
      const relationTargetAttribute = (_b2 = (_a2 = attribute == null ? void 0 : attribute.fieldSchema) == null ? void 0 : _a2.mainField) == null ? void 0 : _b2.name;
      const filterObj = filter[attributeName][relationTargetAttribute];
      if (typeof filterObj === "object" && filterObj !== null) {
        const operator = Object.keys(filterObj)[0];
        const value = filterObj[operator] ?? "";
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          AttributeTag,
          {
            attribute,
            filter,
            onClick: handleClick,
            operator,
            value
          },
          `${attributeName}-${i}`
        );
      }
      return null;
    } else {
      const filterObj = filter[attributeName];
      const operator = Object.keys(filterObj)[0];
      const value = filterObj[operator];
      if (typeof value === "string" || value === null) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          AttributeTag,
          {
            attribute,
            filter,
            onClick: handleClick,
            operator,
            value: value ?? ""
          },
          `${attributeName}-${i}`
        );
      }
      return null;
    }
  }) });
};
const AttributeTag = ({ attribute, filter, onClick, operator, value }) => {
  var _a, _b;
  const { formatMessage, formatDate, formatTime, formatNumber } = useIntl();
  const handleClick = () => {
    onClick(filter);
  };
  const { fieldSchema } = attribute;
  const type = fieldSchema.type === "relation" ? (_b = (_a = fieldSchema == null ? void 0 : fieldSchema.mainField) == null ? void 0 : _a.schema) == null ? void 0 : _b.type : fieldSchema.type;
  let formattedValue = value;
  if (type === "date") {
    formattedValue = formatDate(value, { dateStyle: "full" });
  }
  if (type === "datetime") {
    formattedValue = formatDate(value, { dateStyle: "full", timeStyle: "short" });
  }
  if (type === "time") {
    const [hour, minute] = value.split(":");
    const date = /* @__PURE__ */ new Date();
    date.setHours(Number(hour));
    date.setMinutes(Number(minute));
    formattedValue = formatTime(date, {
      hour: "numeric",
      minute: "numeric"
    });
  }
  if (["float", "integer", "biginteger", "decimal"].includes(type)) {
    formattedValue = formatNumber(Number(value));
  }
  if (attribute.metadatas.customInput) {
    if (attribute.metadatas.options) {
      const selectedOption = attribute.metadatas.options.find((option) => {
        return option.customValue === value;
      });
      formattedValue = (selectedOption == null ? void 0 : selectedOption.label) || value;
    }
  }
  const content = `${attribute.metadatas.label || attribute.name} ${formatMessage({
    id: `components.FilterOptions.FILTER_TYPES.${operator}`,
    defaultMessage: operator
  })} ${operator !== "$null" && operator !== "$notNull" ? formattedValue : ""}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { padding: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { onClick: handleClick, icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Cross, {}), children: content }) });
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return /* @__PURE__ */ new Date(NaN);
  }
}
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
function formatISO(date, options) {
  var _options$format, _options$representati;
  requiredArgs(1, arguments);
  var originalDate = toDate(date);
  if (isNaN(originalDate.getTime())) {
    throw new RangeError("Invalid time value");
  }
  var format = String((_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : "extended");
  var representation = String((_options$representati = options === null || options === void 0 ? void 0 : options.representation) !== null && _options$representati !== void 0 ? _options$representati : "complete");
  if (format !== "extended" && format !== "basic") {
    throw new RangeError("format must be 'extended' or 'basic'");
  }
  if (representation !== "date" && representation !== "time" && representation !== "complete") {
    throw new RangeError("representation must be 'date', 'time', or 'complete'");
  }
  var result = "";
  var tzOffset = "";
  var dateDelimiter = format === "extended" ? "-" : "";
  var timeDelimiter = format === "extended" ? ":" : "";
  if (representation !== "time") {
    var day = addLeadingZeros(originalDate.getDate(), 2);
    var month = addLeadingZeros(originalDate.getMonth() + 1, 2);
    var year = addLeadingZeros(originalDate.getFullYear(), 4);
    result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
  }
  if (representation !== "date") {
    var offset = originalDate.getTimezoneOffset();
    if (offset !== 0) {
      var absoluteOffset = Math.abs(offset);
      var hourOffset = addLeadingZeros(Math.floor(absoluteOffset / 60), 2);
      var minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);
      var sign = offset < 0 ? "+" : "-";
      tzOffset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
    } else {
      tzOffset = "Z";
    }
    var hour = addLeadingZeros(originalDate.getHours(), 2);
    var minute = addLeadingZeros(originalDate.getMinutes(), 2);
    var second = addLeadingZeros(originalDate.getSeconds(), 2);
    var separator = result === "" ? "" : "T";
    var time = [hour, minute, second].join(timeDelimiter);
    result = "".concat(result).concat(separator).concat(time).concat(tzOffset);
  }
  return result;
}
const FilterPopoverURLQuery = ({
  displayedFilters,
  isVisible,
  onBlur,
  onToggle,
  source
}) => {
  var _a;
  const [{ query }, setQuery] = useQueryParams();
  const { formatMessage } = useIntl();
  const { trackUsage } = useTracking();
  const defaultFieldSchema = { fieldSchema: { type: "string" } };
  const [modifiedData, setModifiedData] = React.useState({
    name: ((_a = displayedFilters[0]) == null ? void 0 : _a.name) || "",
    filter: getFilterList((displayedFilters[0] || defaultFieldSchema).fieldSchema)[0].value,
    value: ""
  });
  if (!isVisible) {
    return null;
  }
  if (displayedFilters.length === 0) {
    return null;
  }
  const handleChangeFilterField = (value) => {
    const nextField = displayedFilters.find((f) => f.name === value);
    if (!nextField)
      return;
    const {
      fieldSchema: { type, options }
    } = nextField;
    let filterValue = "";
    if (type === "boolean") {
      filterValue = "true";
    }
    if (type === "enumeration" && Array.isArray(options)) {
      filterValue = options[0];
    }
    const filter = getFilterList(nextField.fieldSchema)[0].value;
    setModifiedData({ name: value, filter, value: filterValue });
  };
  const handleSubmit = (e) => {
    var _a2, _b;
    e.preventDefault();
    const hasFilter = ((_a2 = query == null ? void 0 : query.filters) == null ? void 0 : _a2.$and.find((filter) => {
      var _a3;
      return filter[modifiedData.name] && ((_a3 = filter[modifiedData.name]) == null ? void 0 : _a3[modifiedData.filter]) === modifiedData.value;
    })) !== void 0;
    if (modifiedData.value && !hasFilter) {
      const foundAttribute = displayedFilters.find(({ name }) => name === modifiedData.name);
      if (foundAttribute) {
        if (foundAttribute.trackedEvent) {
          trackUsage(foundAttribute.trackedEvent.name, foundAttribute.trackedEvent.properties);
        }
        let filterToAdd;
        if (foundAttribute.fieldSchema.type === "relation") {
          filterToAdd = {
            [modifiedData.name]: {
              [foundAttribute.fieldSchema.mainField.name]: {
                [modifiedData.filter]: modifiedData.value
              }
            }
          };
        } else {
          filterToAdd = {
            [modifiedData.name]: { [modifiedData.filter]: modifiedData.value }
          };
        }
        const filters = [...((_b = query == null ? void 0 : query.filters) == null ? void 0 : _b.$and) || [], filterToAdd];
        setQuery({ filters: { $and: filters }, page: 1 });
      }
    }
    onToggle();
  };
  const handleChangeOperator = (operator2) => {
    if (operator2 === "$null" || operator2 === "$notNull") {
      setModifiedData((prev) => ({
        ...prev,
        value: "true",
        filter: operator2
      }));
      return;
    }
    setModifiedData((prev) => ({ ...prev, filter: operator2, value: "" }));
  };
  const appliedFilter = displayedFilters.find((filter) => filter.name === modifiedData.name);
  const operator = modifiedData.filter;
  const filterList = appliedFilter.metadatas.customOperators || getFilterList(appliedFilter.fieldSchema);
  const Inputs = appliedFilter.metadatas.customInput || DefaultInputs;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Popover, { source, onDismiss: onToggle, padding: 3, spacing: 4, onBlur, children: /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: handleSubmit, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex$1, { direction: "column", alignItems: "stretch", gap: 1, style: { minWidth: 184 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContainers, { direction: "column", alignItems: "stretch", gap: 1, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SingleSelect,
        {
          label: formatMessage({
            id: "app.utils.select-field",
            defaultMessage: "Select field"
          }),
          name: "name",
          size: "M",
          onChange: handleChangeFilterField,
          value: modifiedData.name,
          children: displayedFilters.map((filter) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(SingleSelectOption, { value: filter.name, children: filter.metadatas.label }, filter.name);
          })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SingleSelect,
        {
          label: formatMessage({
            id: "app.utils.select-filter",
            defaultMessage: "Select filter"
          }),
          name: "filter",
          size: "M",
          value: modifiedData.filter,
          onChange: (value) => (
            // TODO: we should do an assertion function to ensure the value is a valid operator
            handleChangeOperator(value)
          ),
          children: filterList.map((option) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(SingleSelectOption, { value: option.value, children: formatMessage(option.intlLabel) }, option.value);
          })
        }
      )
    ] }),
    operator !== "$null" && operator !== "$notNull" && /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Inputs,
      {
        ...appliedFilter.metadatas,
        ...appliedFilter.fieldSchema,
        value: modifiedData.value,
        onChange: (value) => setModifiedData((prev) => ({ ...prev, value }))
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "L", variant: "secondary", startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, {}), type: "submit", fullWidth: true, children: formatMessage({ id: "app.utils.add-filter", defaultMessage: "Add filter" }) }) })
  ] }) }) });
};
const SelectContainers = styled(Flex$1)`
  /* Hide the label, every input needs a label. */
  label {
    border: 0;
    clip: rect(0 0 0 0);
    height: 1px;
    margin: -1px;
    overflow: hidden;
    padding: 0;
    position: absolute;
    width: 1px;
  }
`;
const DefaultInputs = ({
  label = "",
  onChange,
  options = [],
  type,
  value = ""
}) => {
  const { formatMessage } = useIntl();
  if (type === "boolean") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SingleSelect, { "aria-label": label, onChange: (value2) => onChange(String(value2)), value, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SingleSelectOption, { value: "true", children: "true" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SingleSelectOption, { value: "false", children: "false" })
    ] });
  }
  if (type === "date") {
    return (
      // @ts-expect-error  in V2 of the DS we won't pass label because this will become input only & a label breaks the design
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DatePicker,
        {
          clearLabel: formatMessage({ id: "clearLabel", defaultMessage: "Clear" }),
          ariaLabel: label,
          name: "datepicker",
          onChange: (date) => onChange(date ? formatISO(date, { representation: "date" }) : null),
          onClear: () => onChange(null),
          selectedDate: value ? new Date(value) : void 0
        }
      )
    );
  }
  if (type === "datetime") {
    return (
      // @ts-expect-error  in V2 of the DS we won't pass label because this will become input only & a label breaks the design
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DateTimePicker,
        {
          clearLabel: formatMessage({ id: "clearLabel", defaultMessage: "Clear" }),
          ariaLabel: label,
          name: "datetimepicker",
          onChange: (date) => onChange(date ? date.toISOString() : null),
          onClear: () => onChange(null),
          value: value ? new Date(value) : void 0
        }
      )
    );
  }
  if (type === "enumeration") {
    return (
      // @ts-expect-error from the DS V2 this won't be needed because we're only returning strings.
      /* @__PURE__ */ jsxRuntimeExports.jsx(SingleSelect, { "aria-label": label, onChange, value, children: options.map((optionValue) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SingleSelectOption, { value: optionValue, children: optionValue }, optionValue);
      }) })
    );
  }
  if (["float", "integer", "biginteger", "decimal"].includes(type)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      NumberInput,
      {
        "aria-label": label,
        name: "filter-value",
        onValueChange: (value2) => onChange(value2 ? String(value2) : null),
        value: value || 0
      }
    );
  }
  if (type === "time") {
    return (
      // @ts-expect-error  in V2 of the DS we won't pass label because this will become input only & a label breaks the design
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TimePicker,
        {
          "aria-label": label,
          onClear: () => onChange(""),
          onChange: (value2) => onChange(value2 ? value2 : null),
          value: value ?? void 0,
          clearLabel: "Clear the selected time picker value"
        }
      )
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    FieldInput,
    {
      "aria-label": formatMessage({ id: "app.utils.filter-value", defaultMessage: "Filter value" }),
      onChange: ({ target: { value: value2 } }) => onChange(value2),
      value: value ?? void 0,
      size: "M"
    }
  ) });
};
const getFilterList = (filterSchema) => {
  let type = filterSchema.type;
  if (filterSchema.type === "relation") {
    type = filterSchema.mainField.schema.type;
  }
  switch (type) {
    case "email":
    case "text":
    case "enumeration":
    case "string": {
      return [
        {
          intlLabel: { id: "components.FilterOptions.FILTER_TYPES.$eq", defaultMessage: "is" },
          value: "$eq"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$eqi",
            defaultMessage: "is (case insensitive)"
          },
          value: "$eqi"
        },
        {
          intlLabel: { id: "components.FilterOptions.FILTER_TYPES.$ne", defaultMessage: "is not" },
          value: "$ne"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$nei",
            defaultMessage: "is not (case insensitive)"
          },
          value: "$nei"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$null",
            defaultMessage: "is null"
          },
          value: "$null"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$notNull",
            defaultMessage: "is not null"
          },
          value: "$notNull"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$contains",
            defaultMessage: "contains"
          },
          value: "$contains"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$containsi",
            defaultMessage: "contains (case insensitive)"
          },
          value: "$containsi"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$notContains",
            defaultMessage: "not contains"
          },
          value: "$notContains"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$notContainsi",
            defaultMessage: "not contains (case insensitive)"
          },
          value: "$notContainsi"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$startsWith",
            defaultMessage: "starts with"
          },
          value: "$startsWith"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$startsWithi",
            defaultMessage: "starts with (case insensitive)"
          },
          value: "$startsWithi"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$endsWith",
            defaultMessage: "ends with"
          },
          value: "$endsWith"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$endsWithi",
            defaultMessage: "ends with (case insensitive)"
          },
          value: "$endsWithi"
        }
      ];
    }
    case "float":
    case "integer":
    case "biginteger":
    case "decimal": {
      return [
        {
          intlLabel: { id: "components.FilterOptions.FILTER_TYPES.$eq", defaultMessage: "is" },
          value: "$eq"
        },
        {
          intlLabel: { id: "components.FilterOptions.FILTER_TYPES.$ne", defaultMessage: "is not" },
          value: "$ne"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$null",
            defaultMessage: "is null"
          },
          value: "$null"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$notNull",
            defaultMessage: "is not null"
          },
          value: "$notNull"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$gt",
            defaultMessage: "is greater than"
          },
          value: "$gt"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$gte",
            defaultMessage: "is greater than or equal to"
          },
          value: "$gte"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$lt",
            defaultMessage: "is less than"
          },
          value: "$lt"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$lte",
            defaultMessage: "is less than or equal to"
          },
          value: "$lte"
        }
      ];
    }
    case "time":
    case "date": {
      return [
        {
          intlLabel: { id: "components.FilterOptions.FILTER_TYPES.$eq", defaultMessage: "is" },
          value: "$eq"
        },
        {
          intlLabel: { id: "components.FilterOptions.FILTER_TYPES.$ne", defaultMessage: "is not" },
          value: "$ne"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$null",
            defaultMessage: "is null"
          },
          value: "$null"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$notNull",
            defaultMessage: "is not null"
          },
          value: "$notNull"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$contains",
            defaultMessage: "contains (sensitive)"
          },
          value: "$contains"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$notContains",
            defaultMessage: "not contains (sensitive)"
          },
          value: "$notContains"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$gt",
            defaultMessage: "is greater than"
          },
          value: "$gt"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$gte",
            defaultMessage: "is greater than or equal to"
          },
          value: "$gte"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$lt",
            defaultMessage: "is less than"
          },
          value: "$lt"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$lte",
            defaultMessage: "is less than or equal to"
          },
          value: "$lte"
        }
      ];
    }
    case "datetime": {
      return [
        {
          intlLabel: { id: "components.FilterOptions.FILTER_TYPES.$eq", defaultMessage: "is" },
          value: "$eq"
        },
        {
          intlLabel: { id: "components.FilterOptions.FILTER_TYPES.$ne", defaultMessage: "is not" },
          value: "$ne"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$null",
            defaultMessage: "is null"
          },
          value: "$null"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$notNull",
            defaultMessage: "is not null"
          },
          value: "$notNull"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$gt",
            defaultMessage: "is greater than"
          },
          value: "$gt"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$gte",
            defaultMessage: "is greater than or equal to"
          },
          value: "$gte"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$lt",
            defaultMessage: "is less than"
          },
          value: "$lt"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$lte",
            defaultMessage: "is less than or equal to"
          },
          value: "$lte"
        }
      ];
    }
    default:
      return [
        {
          intlLabel: { id: "components.FilterOptions.FILTER_TYPES.$eq", defaultMessage: "is" },
          value: "$eq"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$eqi",
            defaultMessage: "is (case insensitive)"
          },
          value: "$eqi"
        },
        {
          intlLabel: { id: "components.FilterOptions.FILTER_TYPES.$ne", defaultMessage: "is not" },
          value: "$ne"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$null",
            defaultMessage: "is null"
          },
          value: "$null"
        },
        {
          intlLabel: {
            id: "components.FilterOptions.FILTER_TYPES.$notNull",
            defaultMessage: "is not null"
          },
          value: "$notNull"
        }
      ];
  }
};
const Form = ({ ...props }) => {
  const formRef = React.useRef(null);
  const { isSubmitting, isValidating, errors, touched } = useFormikContext();
  React.useEffect(() => {
    if (isSubmitting && !isValidating) {
      const errorsInForm = formRef.current.querySelectorAll("[data-strapi-field-error]");
      if (errorsInForm && errorsInForm.length > 0) {
        const firstError = errorsInForm[0];
        const describingId = firstError.getAttribute("id");
        const formElementInError = formRef.current.querySelector(
          `[aria-describedby="${describingId}"]`
        );
        if (formElementInError && formElementInError instanceof HTMLElement) {
          formElementInError.focus();
        }
      }
    }
    if (!isSubmitting && !isValidating && Object.keys(errors).length) {
      const el = document.getElementById("global-form-error");
      if (el) {
        el.focus();
      }
    }
  }, [errors, isSubmitting, isValidating, touched]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1, { ref: formRef, ...props, noValidate: true });
};
const useFieldHint = ({ description, fieldSchema, type }) => {
  const { formatMessage } = useIntl();
  const buildDescription = () => (description == null ? void 0 : description.id) ? formatMessage(
    { id: description.id, defaultMessage: description.defaultMessage },
    { ...description.values }
  ) : "";
  const buildHint = () => {
    const { maximum, minimum } = getMinMax(fieldSchema);
    const units = getFieldUnits({
      type,
      minimum,
      maximum
    });
    const minIsNumber = typeof minimum === "number";
    const maxIsNumber = typeof maximum === "number";
    const hasMinAndMax = maxIsNumber && minIsNumber;
    const hasMinOrMax = maxIsNumber || minIsNumber;
    if (!(description == null ? void 0 : description.id) && !hasMinOrMax) {
      return "";
    }
    return formatMessage(
      {
        id: "content-manager.form.Input.hint.text",
        defaultMessage: "{min, select, undefined {} other {min. {min}}}{divider}{max, select, undefined {} other {max. {max}}}{unit}{br}{description}"
      },
      {
        min: minimum,
        max: maximum,
        description: buildDescription(),
        unit: (units == null ? void 0 : units.message) && hasMinOrMax ? formatMessage(units.message, units.values) : null,
        divider: hasMinAndMax ? formatMessage({
          id: "content-manager.form.Input.hint.minMaxDivider",
          defaultMessage: " / "
        }) : null,
        br: hasMinOrMax ? /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}) : null
      }
    );
  };
  return { hint: buildHint() };
};
const getFieldUnits = ({
  type,
  minimum,
  maximum
}) => {
  if (type && ["biginteger", "integer", "number"].includes(type)) {
    return {};
  }
  const maxValue = Math.max(minimum || 0, maximum || 0);
  return {
    message: {
      id: "content-manager.form.Input.hint.character.unit",
      defaultMessage: "{maxValue, plural, one { character} other { characters}}"
    },
    values: {
      maxValue
    }
  };
};
const getMinMax = (fieldSchema) => {
  if (!fieldSchema) {
    return { maximum: void 0, minimum: void 0 };
  }
  const { minLength, maxLength, max, min } = fieldSchema;
  let minimum;
  let maximum;
  const parsedMin = Number(min);
  const parsedMinLength = Number(minLength);
  if (!Number.isNaN(parsedMin)) {
    minimum = parsedMin;
  } else if (!Number.isNaN(parsedMinLength)) {
    minimum = parsedMinLength;
  }
  const parsedMax = Number(max);
  const parsedMaxLength = Number(maxLength);
  if (!Number.isNaN(parsedMax)) {
    maximum = parsedMax;
  } else if (!Number.isNaN(parsedMaxLength)) {
    maximum = parsedMaxLength;
  }
  return { maximum, minimum };
};
const useQuery = () => {
  const { search } = useLocation();
  return useMemo(() => new URLSearchParams(search), [search]);
};
const useFocusInputField = (name) => {
  const search = useQuery();
  const [field, setField] = useState(null);
  useEffect(() => {
    if (search.has("field") && search.get("field") === name && field) {
      if ("input" in field) {
        field.input.current.focus();
        field.input.current.scrollIntoView({
          block: "center"
        });
      } else {
        field.focus();
        field.scrollIntoView({
          block: "center"
        });
      }
    }
  }, [search, name, field]);
  return setField;
};
const pxToRem = (px) => `${px / 16}rem`;
const GenericInput = ({
  autoComplete,
  customInputs,
  description,
  disabled,
  intlLabel,
  labelAction,
  error,
  name,
  onChange,
  options = [],
  placeholder,
  required,
  step,
  type,
  value: defaultValue,
  isNullable,
  attribute,
  ...rest
}) => {
  const { formatMessage } = useIntl();
  const getFieldHintValue = (attribute2, key) => {
    if (!attribute2)
      return;
    if (key === "minLength" && key in attribute2) {
      return attribute2[key];
    }
    if (key === "maxLength" && key in attribute2) {
      return attribute2[key];
    }
    if (key === "max" && key in attribute2) {
      return attribute2[key];
    }
    if (key === "min" && key in attribute2) {
      return attribute2[key];
    }
  };
  const { hint } = useFieldHint({
    description,
    fieldSchema: {
      minLength: getFieldHintValue(attribute, "minLength"),
      maxLength: getFieldHintValue(attribute, "maxLength"),
      max: getFieldHintValue(attribute, "max"),
      min: getFieldHintValue(attribute, "min")
    },
    type: (attribute == null ? void 0 : attribute.type) || type
  });
  const [showPassword, setShowPassword] = React.useState(false);
  const fieldRef = useFocusInputField(name);
  const CustomInput = customInputs ? customInputs[type] : null;
  const value = defaultValue ?? void 0;
  const valueWithEmptyStringFallback = value ?? "";
  function getErrorMessage(error2) {
    if (!error2) {
      return null;
    }
    if (typeof error2 === "string") {
      return formatMessage({ id: error2, defaultMessage: error2 });
    }
    const values = {
      ...error2.values
    };
    return formatMessage(
      {
        id: error2.id,
        defaultMessage: (error2 == null ? void 0 : error2.defaultMessage) ?? error2.id
      },
      values
    );
  }
  const errorMessage = getErrorMessage(error) ?? void 0;
  if (CustomInput) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CustomInput,
      {
        ...rest,
        ref: fieldRef,
        attribute,
        description,
        hint,
        disabled,
        intlLabel,
        labelAction,
        error: errorMessage || "",
        name,
        onChange,
        options,
        required,
        placeholder,
        type,
        value
      }
    );
  }
  const label = intlLabel.id ? formatMessage(
    { id: intlLabel.id, defaultMessage: intlLabel.defaultMessage },
    { ...intlLabel.values }
  ) : name;
  const formattedPlaceholder = placeholder ? formatMessage(
    { id: placeholder.id, defaultMessage: placeholder.defaultMessage },
    { ...placeholder.values }
  ) : "";
  switch (type) {
    case "json": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        JSONInput,
        {
          ref: fieldRef,
          label,
          labelAction,
          value,
          error: errorMessage,
          disabled,
          hint,
          required,
          onChange: (json) => {
            const value2 = "required" in attribute && !(attribute == null ? void 0 : attribute.required) && !json.length ? null : json;
            onChange({ target: { name, value: value2 } }, false);
          },
          minHeight: pxToRem(252),
          maxHeight: pxToRem(504)
        }
      );
    }
    case "bool": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToggleInput,
        {
          ref: fieldRef,
          checked: defaultValue === null ? null : defaultValue || false,
          disabled,
          hint,
          label,
          error: errorMessage,
          labelAction,
          name,
          offLabel: formatMessage({
            id: "app.components.ToggleCheckbox.off-label",
            defaultMessage: "False"
          }),
          onLabel: formatMessage({
            id: "app.components.ToggleCheckbox.on-label",
            defaultMessage: "True"
          }),
          onChange: (e) => {
            onChange({ target: { name, value: e.target.checked } });
          },
          required,
          onClear: () => {
            onChange({ target: { name, value: null } });
          },
          clearLabel: isNullable ? formatMessage({
            id: "app.components.ToggleCheckbox.clear-label",
            defaultMessage: "Clear"
          }) : void 0
        }
      );
    }
    case "checkbox": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Checkbox,
        {
          ref: fieldRef,
          disabled,
          error: errorMessage,
          hint,
          id: name,
          name,
          onValueChange: (value2) => {
            onChange({ target: { name, value: value2 } });
          },
          required,
          value: Boolean(value),
          children: label
        }
      );
    }
    case "datetime": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        DateTimePicker,
        {
          ref: fieldRef,
          clearLabel: formatMessage({ id: "clearLabel", defaultMessage: "Clear" }),
          disabled,
          error: errorMessage,
          label,
          labelAction,
          id: name,
          hint,
          name,
          onChange: (date) => {
            const formattedDate = date ? date.toISOString() : null;
            onChange({ target: { name, value: formattedDate, type } });
          },
          onClear: () => onChange({ target: { name, value: null, type } }),
          placeholder: formattedPlaceholder,
          required,
          value
        }
      );
    }
    case "date": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        DatePicker,
        {
          ref: fieldRef,
          clearLabel: formatMessage({ id: "clearLabel", defaultMessage: "Clear" }),
          disabled,
          error: errorMessage,
          label,
          id: name,
          hint,
          name,
          onChange: (date) => {
            onChange({
              target: {
                name,
                value: date ? formatISO(date, { representation: "date" }) : null,
                type
              }
            });
          },
          onClear: () => onChange({ target: { name, value: null, type } }),
          placeholder: formattedPlaceholder,
          required,
          selectedDate: value
        }
      );
    }
    case "number": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        NumberInput,
        {
          ref: fieldRef,
          disabled,
          error: errorMessage,
          label,
          labelAction,
          id: name,
          hint,
          name,
          onValueChange: (value2) => {
            onChange({ target: { name, value: value2, type } });
          },
          placeholder: formattedPlaceholder,
          required,
          step,
          value
        }
      );
    }
    case "email": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          ref: fieldRef,
          autoComplete,
          disabled,
          error: errorMessage,
          label,
          labelAction,
          id: name,
          hint,
          name,
          onChange: (e) => {
            onChange({ target: { name, value: e.target.value, type } });
          },
          placeholder: formattedPlaceholder,
          required,
          type: "email",
          value: valueWithEmptyStringFallback
        }
      );
    }
    case "timestamp":
    case "text":
    case "string": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          ref: fieldRef,
          autoComplete,
          disabled,
          error: errorMessage,
          label,
          labelAction,
          id: name,
          hint,
          name,
          onChange: (e) => {
            onChange({ target: { name, value: e.target.value, type } });
          },
          placeholder: formattedPlaceholder,
          required,
          type: "text",
          value: valueWithEmptyStringFallback
        }
      );
    }
    case "password": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          ref: fieldRef,
          autoComplete,
          disabled,
          error: errorMessage,
          endAction: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              "aria-label": formatMessage({
                id: "Auth.form.password.show-password",
                defaultMessage: "Show password"
              }),
              onClick: () => {
                setShowPassword((prev) => !prev);
              },
              style: {
                border: "none",
                padding: 0,
                background: "transparent"
              },
              type: "button",
              children: showPassword ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { as: Eye, color: "neutral500" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { as: EyeStriked, color: "neutral500" })
            }
          ),
          label,
          labelAction,
          id: name,
          hint,
          name,
          onChange: (e) => {
            onChange({ target: { name, value: e.target.value, type } });
          },
          placeholder: formattedPlaceholder,
          required,
          type: showPassword ? "text" : "password",
          value: valueWithEmptyStringFallback
        }
      );
    }
    case "select": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SingleSelect,
        {
          ref: fieldRef,
          disabled,
          error: errorMessage,
          label,
          labelAction,
          id: name,
          hint,
          name,
          onChange: (value2) => {
            onChange({ target: { name, value: value2, type: "select" } });
          },
          placeholder: formattedPlaceholder,
          required,
          value,
          children: options.map(({ metadatas: { intlLabel: intlLabel2, disabled: disabled2, hidden }, key, value: value2 }) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(SingleSelectOption, { value: value2, disabled: disabled2, hidden, children: formatMessage(intlLabel2) }, key);
          })
        }
      );
    }
    case "textarea": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Textarea,
        {
          ref: fieldRef,
          disabled,
          error: errorMessage,
          label,
          labelAction,
          id: name,
          hint,
          name,
          onChange: (event) => onChange({ target: { name, value: event.target.value, type } }),
          required,
          placeholder: formattedPlaceholder,
          value: valueWithEmptyStringFallback
        }
      );
    }
    case "time": {
      let time = value;
      if (typeof value === "string" && value.split(":").length > 2) {
        const [hour, minute] = value.split(":");
        time = `${hour}:${minute}`;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TimePicker,
        {
          ref: fieldRef,
          clearLabel: formatMessage({ id: "clearLabel", defaultMessage: "Clear" }),
          disabled,
          error: errorMessage,
          label,
          labelAction,
          id: name,
          hint,
          name,
          onChange: (time2) => {
            onChange({ target: { name, value: `${time2}`, type } });
          },
          onClear: () => {
            onChange({ target: { name, value: null, type } });
          },
          required,
          value: time
        }
      );
    }
    default: {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          disabled: true,
          error: errorMessage,
          label,
          labelAction,
          id: name,
          hint,
          name,
          placeholder: "Not supported",
          required,
          type: "text",
          value: ""
        }
      );
    }
  }
};
const StrapiAppContext = React.createContext({
  getPlugin: () => void 0,
  menu: [],
  plugins: {},
  settings: {},
  // These functions are required but should not resolve to undefined as they do here
  runHookParallel: () => Promise.resolve(),
  runHookWaterfall: () => Promise.resolve(),
  runHookSeries: () => Promise.resolve()
});
const StrapiAppProvider = ({
  children,
  getPlugin,
  menu,
  plugins,
  runHookParallel,
  runHookSeries,
  runHookWaterfall,
  settings
}) => {
  const contextValue = React.useMemo(
    () => ({
      getPlugin,
      menu,
      plugins,
      runHookParallel,
      runHookSeries,
      runHookWaterfall,
      settings
    }),
    [getPlugin, menu, plugins, runHookParallel, runHookSeries, runHookWaterfall, settings]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StrapiAppContext.Provider, { value: contextValue, children });
};
const useStrapiApp = () => React.useContext(StrapiAppContext);
const InjectionZone = ({
  area,
  ...props
}) => {
  const { getPlugin } = useStrapiApp();
  const [pluginName, page, position] = area.split(".");
  const plugin = getPlugin(pluginName);
  if (!plugin) {
    return null;
  }
  const components2 = plugin.getInjectedComponents(page, position);
  if (!components2) {
    return null;
  }
  return components2.map(({ name, Component }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ...props }, name));
};
/**
 * @preserve
 *
 * @deprecated Use @strapi/design-system LinkButton instead.
 */
const Link = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Link$1, { ...props, as: NavLink });
/**
 * @preserve
 *
 * @deprecated Use @strapi/design-system LinkButton instead.
 */
const LinkButton = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(LinkButton$1, { ...props, as: NavLink });
const NoContent = ({
  content = {
    id: "app.components.EmptyStateLayout.content-document",
    defaultMessage: "No content found",
    values: {}
  },
  ...rest
}) => {
  const { formatMessage } = useIntl();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    EmptyStateLayout$1,
    {
      ...rest,
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyDocuments, { width: "10rem" }),
      content: formatMessage(
        { id: content.id, defaultMessage: content.defaultMessage },
        content.values
      )
    }
  );
};
const NoMedia = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyStateLayout$1, { ...props, icon: /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyPictures, { width: "10rem" }) });
};
const NoPermissions = ({ action }) => {
  const { formatMessage } = useIntl();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    EmptyStateLayout$1,
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyPermissions, { width: "10rem" }),
      content: formatMessage({
        id: "app.components.EmptyStateLayout.content-permissions",
        defaultMessage: "You don't have the permissions to access that content"
      }),
      action
    }
  );
};
const NotAllowedInput = ({
  description,
  error,
  intlLabel,
  labelAction,
  name = ""
}) => {
  const { formatMessage } = useIntl();
  const label = (intlLabel == null ? void 0 : intlLabel.id) ? formatMessage(
    { id: intlLabel.id, defaultMessage: intlLabel.defaultMessage },
    { ...intlLabel.values }
  ) : name;
  const hint = (description == null ? void 0 : description.id) ? formatMessage(
    { id: description.id, defaultMessage: description.defaultMessage },
    { ...description.values }
  ) : "";
  const placeholder = formatMessage({
    id: "components.NotAllowedInput.text",
    defaultMessage: "No permissions to see this field"
  });
  const errorMessage = error ? formatMessage({ id: error, defaultMessage: error }) : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextInput,
    {
      disabled: true,
      error: errorMessage,
      label,
      labelAction,
      id: name,
      hint,
      name,
      placeholder,
      startAction: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledIcon, {}),
      type: "text",
      value: ""
    }
  );
};
const StyledIcon = styled(EyeStriked)`
  & > path {
    fill: ${({ theme }) => theme.colors.neutral600};
  }
`;
const PageSizeURLQuery = ({
  trackedEvent,
  options = ["10", "20", "50", "100"],
  defaultValue = "10"
}) => {
  const { formatMessage } = useIntl();
  const [{ query }, setQuery] = useQueryParams();
  const { trackUsage } = useTracking();
  const handleChange = (value) => {
    if (trackedEvent) {
      trackUsage(trackedEvent);
    }
    setQuery({
      pageSize: value,
      page: 1
    });
  };
  const pageSize = typeof (query == null ? void 0 : query.pageSize) === "string" && (query == null ? void 0 : query.pageSize) !== "" ? query.pageSize : defaultValue;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex$1, { gap: 2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SingleSelect,
      {
        size: "S",
        "aria-label": formatMessage({
          id: "components.PageFooter.select",
          defaultMessage: "Entries per page"
        }),
        onChange: handleChange,
        value: pageSize,
        children: options.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(SingleSelectOption, { value: option, children: option }, option))
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textColor: "neutral600", as: "span", children: formatMessage({
      id: "components.PageFooter.select",
      defaultMessage: "Entries per page"
    }) })
  ] });
};
const PaginationURLQuery = ({
  pagination: { pageCount },
  boundaryCount = 1,
  siblingCount = 1
}) => {
  const [{ query }] = useQueryParams();
  const activePage = parseInt((query == null ? void 0 : query.page) || "1", 10);
  const { pathname } = useLocation();
  const { formatMessage } = useIntl();
  const makeSearch = (page) => stringify$1({ ...query, page }, { encode: false });
  const nextSearch = makeSearch(activePage + (pageCount > 1 ? 1 : 0));
  const previousSearch = makeSearch(activePage - 1);
  const range = (start, end) => {
    const length = end - start + 1;
    return Array.from({ length }, (_, i) => start + i);
  };
  const startPages = range(1, Math.min(boundaryCount, pageCount));
  const endPages = range(Math.max(pageCount - boundaryCount + 1, boundaryCount + 1), pageCount);
  const siblingsStart = Math.max(
    Math.min(
      // Natural start
      activePage - siblingCount,
      // Lower boundary when page is high
      pageCount - boundaryCount - siblingCount * 2 - 1
    ),
    // Greater than startPages
    boundaryCount + 2
  );
  const siblingsEnd = Math.min(
    Math.max(
      // Natural end
      activePage + siblingCount,
      // Upper boundary when page is low
      boundaryCount + siblingCount * 2 + 2
    ),
    // Less than endPages
    endPages.length > 0 ? endPages[0] - 2 : pageCount - 1
  );
  const items = [
    ...startPages,
    // Start ellipsis
    // eslint-disable-next-line no-nested-ternary
    ...siblingsStart > boundaryCount + 2 ? ["start-ellipsis"] : boundaryCount + 1 < pageCount - boundaryCount ? [boundaryCount + 1] : [],
    // Sibling pages
    ...range(siblingsStart, siblingsEnd),
    // End ellipsis
    // eslint-disable-next-line no-nested-ternary
    ...siblingsEnd < pageCount - boundaryCount - 1 ? ["end-ellipsis"] : pageCount - boundaryCount > boundaryCount ? [pageCount - boundaryCount] : [],
    ...endPages
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Pagination, { activePage, pageCount, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PreviousLink, { active: false, to: { pathname, search: previousSearch }, children: formatMessage({
      id: "components.pagination.go-to-previous",
      defaultMessage: "Go to previous page"
    }) }),
    items.map((item) => {
      if (typeof item === "number") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          PageLink,
          {
            active: item === activePage,
            number: item,
            to: { pathname, search: makeSearch(item) },
            children: formatMessage(
              { id: "components.pagination.go-to", defaultMessage: "Go to page {page}" },
              { page: item }
            )
          },
          item
        );
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Dots, {}, item);
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(NextLink, { active: false, to: { pathname, search: nextSearch }, children: formatMessage({
      id: "components.pagination.go-to-next",
      defaultMessage: "Go to next page"
    }) })
  ] });
};
const ReactSelect = ({
  components: components2,
  styles,
  error,
  ariaErrorMessage,
  ...props
}) => {
  const theme = useTheme();
  const customStyles = getSelectStyles(theme, error);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Select,
    {
      menuPosition: "fixed",
      components: {
        ClearIndicator,
        DropdownIndicator,
        IndicatorSeparator: () => null,
        LoadingIndicator: () => null,
        ...components2
      },
      "aria-errormessage": error && ariaErrorMessage,
      "aria-invalid": !!error,
      styles: { ...customStyles, ...styles },
      ...props
    }
  );
};
const IconBox$1 = styled(Box$1)`
  background: transparent;
  border: none;
  position: relative;
  z-index: 1;

  svg {
    height: ${11 / 16}rem;
    width: ${11 / 16}rem;
  }

  svg path {
    fill: ${({ theme }) => theme.colors.neutral600};
  }
`;
const ClearIndicator = (props) => {
  const Component = components.ClearIndicator;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBox$1, { as: "button", type: "button", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Cross, {}) }) });
};
const CarretBox = styled(IconBox$1)`
  display: flex;
  background: none;
  border: none;

  svg {
    width: ${9 / 16}rem;
  }
`;
const DropdownIndicator = ({ innerProps }) => {
  return (
    // @ts-expect-error  issue with the ref attached to `innerProps`
    /* @__PURE__ */ jsxRuntimeExports.jsx(CarretBox, { paddingRight: 3, ...innerProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CarretDown, {}) })
  );
};
const getSelectStyles = (theme, error) => {
  return {
    clearIndicator: (base) => ({ ...base, padding: 0, paddingRight: theme.spaces[3] }),
    container: (base) => ({
      ...base,
      background: theme.colors.neutral0,
      lineHeight: "normal"
    }),
    control(base, state) {
      let borderColor = theme.colors.neutral200;
      let boxShadowColor;
      let backgroundColor;
      if (state.isFocused) {
        borderColor = theme.colors.primary600;
        boxShadowColor = theme.colors.primary600;
      } else if (error) {
        borderColor = theme.colors.danger600;
      }
      if (state.isDisabled) {
        backgroundColor = `${theme.colors.neutral150} !important`;
      }
      return {
        ...base,
        fontSize: theme.fontSizes[2],
        height: 40,
        border: `1px solid ${borderColor} !important`,
        outline: 0,
        backgroundColor,
        borderRadius: theme.borderRadius,
        boxShadow: boxShadowColor ? `${boxShadowColor} 0px 0px 0px 2px` : ""
      };
    },
    indicatorsContainer: (base) => ({ ...base, padding: 0, paddingRight: theme.spaces[3] }),
    input: (base) => ({
      ...base,
      margin: 0,
      padding: 0,
      color: theme.colors.neutral800,
      gridTemplateColumns: "0 100%"
    }),
    menu(base) {
      return {
        ...base,
        width: "100%",
        marginTop: theme.spaces[1],
        backgroundColor: theme.colors.neutral0,
        color: theme.colors.neutral800,
        borderRadius: theme.borderRadius,
        border: `1px solid ${theme.colors.neutral200}`,
        boxShadow: theme.shadows.tableShadow,
        fontSize: theme.fontSizes[2],
        zIndex: 2
      };
    },
    menuList: (base) => ({
      ...base,
      paddingLeft: theme.spaces[1],
      paddingTop: theme.spaces[1],
      paddingRight: theme.spaces[1],
      paddingBottom: theme.spaces[1]
    }),
    menuPortal: (base) => ({
      ...base,
      zIndex: 100
    }),
    option(base, state) {
      let backgroundColor = base.backgroundColor;
      if (state.isFocused || state.isSelected) {
        backgroundColor = theme.colors.primary100;
      }
      return {
        ...base,
        color: theme.colors.neutral800,
        lineHeight: theme.spaces[5],
        backgroundColor,
        borderRadius: theme.borderRadius,
        "&:active": {
          backgroundColor: theme.colors.primary100
        }
      };
    },
    placeholder: (base) => ({
      ...base,
      color: theme.colors.neutral600,
      marginLeft: 0,
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      maxWidth: "80%"
    }),
    singleValue(base, state) {
      let color = theme.colors.neutral800;
      if (state.isDisabled) {
        color = theme.colors.neutral600;
      }
      return { ...base, marginLeft: 0, color };
    },
    valueContainer: (base) => ({
      ...base,
      cursor: "pointer",
      padding: 0,
      paddingLeft: theme.spaces[4],
      marginLeft: 0,
      marginRight: 0
    })
  };
};
const intervals = ["years", "months", "days", "hours", "minutes", "seconds"];
const RelativeTime = ({ timestamp, customIntervals = [] }) => {
  const { formatRelativeTime, formatDate, formatTime } = useIntl();
  const interval = intervalToDuration({
    start: timestamp,
    end: Date.now()
    // see https://github.com/date-fns/date-fns/issues/2891  No idea why it's all partial it returns it every time.
  });
  const unit = intervals.find((intervalUnit) => {
    return interval[intervalUnit] > 0 && Object.keys(interval).includes(intervalUnit);
  });
  const relativeTime = isPast(timestamp) ? -interval[unit] : interval[unit];
  const customInterval = customIntervals.find((custom) => interval[custom.unit] < custom.threshold);
  const displayText = customInterval ? customInterval.text : formatRelativeTime(relativeTime, unit, { numeric: "auto" });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "time",
    {
      dateTime: timestamp.toISOString(),
      title: `${formatDate(timestamp)} ${formatTime(timestamp)}`,
      children: displayText
    }
  );
};
const SearchURLQuery = ({
  label,
  placeholder,
  trackedEvent,
  trackedEventDetails
}) => {
  const inputRef = React.useRef(null);
  const iconButtonRef = React.useRef(null);
  const [{ query }, setQuery] = useQueryParams();
  const [value, setValue] = React.useState((query == null ? void 0 : query._q) || "");
  const [isOpen, setIsOpen] = React.useState(!!value);
  const { formatMessage } = useIntl();
  const { trackUsage } = useTracking();
  const handleToggle = () => setIsOpen((prev) => !prev);
  React.useLayoutEffect(() => {
    if (isOpen && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isOpen]);
  const handleClear = () => {
    setValue("");
    setQuery({ _q: "" }, "remove");
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    if (value) {
      if (trackedEvent) {
        trackUsage(trackedEvent, trackedEventDetails);
      }
      setQuery({ _q: encodeURIComponent(value), page: 1 });
    } else {
      handleToggle();
      setQuery({ _q: "" }, "remove");
    }
  };
  if (isOpen) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SearchForm, { onSubmit: handleSubmit, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Searchbar,
      {
        ref: inputRef,
        name: "search",
        onChange: (e) => setValue(e.target.value),
        value,
        clearLabel: formatMessage({ id: "clearLabel", defaultMessage: "Clear" }),
        onClear: handleClear,
        size: "S",
        placeholder,
        children: label
      }
    ) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    IconButton,
    {
      ref: iconButtonRef,
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { as: Search, color: "neutral800" }),
      label: formatMessage({ id: "global.search", defaultMessage: "Search" }),
      onClick: handleToggle
    }
  );
};
const SettingsPageTitle = ({ name }) => {
  const { formatMessage } = useIntl();
  const text = formatMessage(
    { id: "Settings.PageTitle", defaultMessage: "Settings - {name}" },
    { name }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Helmet, { title: text });
};
const Bullet = styled.div`
  margin-right: ${({ theme }) => theme.spaces[3]};
  width: ${6 / 16}rem;
  height: ${6 / 16}rem;
  border-radius: 50%;
  background: ${({ theme, backgroundColor }) => theme.colors[backgroundColor]};
`;
const Status = ({ variant = "primary" }) => {
  const backgroundColor = `${variant}600`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Bullet, { backgroundColor });
};
const ContentManagerEditViewDataManagerContext = React.createContext({
  allLayoutData: {
    components: {}
  },
  createActionAllowedFields: [],
  formErrors: {},
  hasDraftAndPublish: false,
  initialData: {},
  isCreatingEntry: false,
  isSingleType: false,
  modifiedData: {},
  readActionAllowedFields: [],
  slug: void 0,
  upateActionAllowedFields: []
});
const useCMEditViewDataManager = () => React.useContext(ContentManagerEditViewDataManagerContext);
var baseGetTag = _baseGetTag, isObjectLike$1 = isObjectLike_1;
var symbolTag$1 = "[object Symbol]";
function isSymbol$4(value) {
  return typeof value == "symbol" || isObjectLike$1(value) && baseGetTag(value) == symbolTag$1;
}
var isSymbol_1 = isSymbol$4;
var isArray$8 = isArray_1, isSymbol$3 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$3(value, object) {
  if (isArray$8(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$3(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$3;
var getNative = _getNative;
var nativeCreate$4 = getNative(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$4.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$2(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$2;
var eq$1 = eq_1;
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index = assocIndexOf$3(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index = assocIndexOf$2(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var Hash = _Hash, ListCache$3 = _ListCache, Map$2 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache$3)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var MapCache$2 = _MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache$2)();
  return memoized;
}
memoize$1.Cache = MapCache$2;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap$1(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var _arrayMap = arrayMap$1;
var Symbol$2 = _Symbol, arrayMap = _arrayMap, isArray$7 = isArray_1, isSymbol$2 = isSymbol_1;
var INFINITY$2 = 1 / 0;
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString$2(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$7(value)) {
    return arrayMap(value, baseToString$2) + "";
  }
  if (isSymbol$2(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
var _baseToString = baseToString$2;
var baseToString$1 = _baseToString;
function toString$2(value) {
  return value == null ? "" : baseToString$1(value);
}
var toString_1 = toString$2;
var isArray$6 = isArray_1, isKey$2 = _isKey, stringToPath = _stringToPath, toString$1 = toString_1;
function castPath$2(value, object) {
  if (isArray$6(value)) {
    return value;
  }
  return isKey$2(value, object) ? [value] : stringToPath(toString$1(value));
}
var _castPath = castPath$2;
var isSymbol$1 = isSymbol_1;
var INFINITY$1 = 1 / 0;
function toKey$4(value) {
  if (typeof value == "string" || isSymbol$1(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _toKey = toKey$4;
var castPath$1 = _castPath, toKey$3 = _toKey;
function baseGet$2(object, path) {
  path = castPath$1(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey$3(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var _baseGet = baseGet$2;
var baseGet$1 = _baseGet;
function get$1(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet$1(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$1;
const get$2 = /* @__PURE__ */ getDefaultExportFromCjs(get_1);
const getType = (schema, attrName) => get$2(schema, ["attributes", attrName, "type"], "");
const getOtherInfos = (schema, arr) => get$2(schema, ["attributes", ...arr], "");
const AutoReloadOverlayBlockerContext = React.createContext(
  {}
);
const MAX_ELAPSED_TIME = 30 * 1e3;
const AutoReloadOverlayBlockerProvider = ({ children }) => {
  const [isOpen, setIsOpen] = React.useState(false);
  const [config, setConfig] = React.useState({});
  const [failed, setFailed] = React.useState(false);
  const lockAppWithAutoreload = React.useCallback((config2 = {}) => {
    setIsOpen(true);
    setConfig(config2);
  }, []);
  const unlockAppWithAutoreload = React.useCallback(() => {
    setIsOpen(false);
    setConfig({});
  }, []);
  React.useEffect(() => {
    if (isOpen) {
      const timeout = setTimeout(() => {
        setFailed(true);
      }, MAX_ELAPSED_TIME);
      return () => {
        clearTimeout(timeout);
      };
    }
  }, [isOpen]);
  let displayedIcon = (config == null ? void 0 : config.icon) || "reload";
  let description = {
    id: (config == null ? void 0 : config.description) || "components.OverlayBlocker.description",
    defaultMessage: "You're using a feature that needs the server to restart. Please wait until the server is up."
  };
  let title = {
    id: (config == null ? void 0 : config.title) || "components.OverlayBlocker.title",
    defaultMessage: "Waiting for restart"
  };
  if (failed) {
    displayedIcon = "time";
    description = {
      id: "components.OverlayBlocker.description.serverError",
      defaultMessage: "The server should have restarted, please check your logs in the terminal."
    };
    title = {
      id: "components.OverlayBlocker.title.serverError",
      defaultMessage: "The restart is taking longer than expected"
    };
  }
  const autoReloadValue = React.useMemo(
    () => ({
      lockAppWithAutoreload,
      unlockAppWithAutoreload
    }),
    [lockAppWithAutoreload, unlockAppWithAutoreload]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(AutoReloadOverlayBlockerContext.Provider, { value: autoReloadValue, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Blocker,
      {
        displayedIcon,
        isOpen,
        description,
        title
      }
    ),
    children
  ] });
};
const Blocker = ({ displayedIcon, description, title, isOpen }) => {
  var _a;
  const { formatMessage } = useIntl();
  return isOpen && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body) ? createPortal(
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Overlay$1, { id: "autoReloadOverlayBlocker", direction: "column", alignItems: "center", gap: 6, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex$1, { direction: "column", alignItems: "center", gap: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { as: "h1", variant: "alpha", children: formatMessage(title) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { as: "h2", textColor: "neutral600", fontSize: 4, fontWeight: "regular", children: formatMessage(description) })
      ] }),
      displayedIcon === "reload" && /* @__PURE__ */ jsxRuntimeExports.jsx(IconBox, { padding: 6, background: "primary100", borderColor: "primary200", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoaderReload, { width: pxToRem(36), height: pxToRem(36) }) }),
      displayedIcon === "time" && /* @__PURE__ */ jsxRuntimeExports.jsx(IconBox, { padding: 6, background: "primary100", borderColor: "primary200", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { width: pxToRem(40), height: pxToRem(40) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { marginTop: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link$1, { href: "https://docs.strapi.io", isExternal: true, children: formatMessage({
        id: "global.documentation",
        defaultMessage: "Read the documentation"
      }) }) })
    ] }),
    // eslint-disable-next-line no-undef
    globalThis.document.body
  ) : null;
};
const rotation = keyframes`
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(359deg);
    }
  `;
const LoaderReload = styled(Refresh)`
  animation: ${rotation} 1s infinite linear;
`;
const Overlay$1 = styled(Flex$1)`
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  /* TODO: set this up in the theme for consistence z-index values */
  z-index: 1140;
  padding-top: ${pxToRem(160)};

  & > * {
    position: relative;
    z-index: 1;
  }

  &:before {
    content: '';
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background: ${({ theme }) => theme.colors.neutral0};
    opacity: 0.9;
  }
`;
const IconBox = styled(Box$1)`
  border-radius: 50%;
  svg {
    > path {
      fill: ${({ theme }) => theme.colors.primary600} !important;
    }
  }
`;
const useAutoReloadOverlayBlocker = () => React.useContext(AutoReloadOverlayBlockerContext);
const CustomFieldsContext = React.createContext({
  get() {
    return void 0;
  },
  getAll() {
    return {};
  }
});
const CustomFieldsProvider = ({ children, customFields }) => {
  const get2 = customFields.get.bind(customFields);
  const getAll = customFields.getAll.bind(customFields);
  const value = React.useMemo(() => ({ get: get2, getAll }), [get2, getAll]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CustomFieldsContext.Provider, { value, children });
};
const useCustomFields = () => React.useContext(CustomFieldsContext);
const GuidedTourContext = React.createContext({
  currentStep: null,
  guidedTourState: {
    contentTypeBuilder: {
      create: false,
      success: false
    },
    contentManager: {
      create: false,
      success: false
    },
    apiTokens: {
      create: false,
      success: false
    }
  },
  isGuidedTourVisible: false,
  isSkipped: true,
  setCurrentStep: () => null,
  setGuidedTourVisibility: () => null,
  setSkipped: () => null,
  setStepState: () => null,
  startSection: () => null
});
const GuidedTourProvider = ({
  children,
  currentStep = null,
  guidedTourState,
  isGuidedTourVisible = false,
  isSkipped,
  setCurrentStep,
  setGuidedTourVisibility,
  setSkipped,
  setStepState,
  startSection
}) => {
  const value = React.useMemo(
    () => ({
      currentStep,
      guidedTourState,
      isGuidedTourVisible,
      isSkipped,
      setCurrentStep,
      setGuidedTourVisibility,
      setSkipped,
      setStepState,
      startSection
    }),
    [
      currentStep,
      guidedTourState,
      isGuidedTourVisible,
      isSkipped,
      setCurrentStep,
      setGuidedTourVisibility,
      setSkipped,
      setStepState,
      startSection
    ]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedTourContext.Provider, { value, children });
};
const useGuidedTour = () => React.useContext(GuidedTourContext);
const LibraryContext = React.createContext({});
const LibraryProvider = ({ children, fields, components: components2 }) => {
  const value = React.useMemo(() => ({ fields, components: components2 }), [fields, components2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LibraryContext.Provider, { value, children });
};
const useLibrary = () => React.useContext(LibraryContext);
const OverlayBlockerContext = React.createContext({});
const OverlayBlockerProvider = ({ children }) => {
  var _a;
  const [isOpen, setIsOpen] = React.useState(false);
  const lockApp = React.useCallback(() => {
    setIsOpen(true);
  }, []);
  const unlockApp = React.useCallback(() => {
    setIsOpen(false);
  }, []);
  const contextValue = React.useMemo(() => ({ lockApp, unlockApp }), [lockApp, unlockApp]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(OverlayBlockerContext.Provider, { value: contextValue, children: [
    children,
    isOpen && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body) ? createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Overlay, { id: "overlayBlocker" }), globalThis.document.body) : null
  ] });
};
const Overlay = styled(Box$1)`
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  /* TODO: set this up in the theme for consistence z-index values */
  z-index: 1140;
`;
const useOverlayBlocker = () => React.useContext(OverlayBlockerContext);
const ERROR_PREFIX = "apiError.";
function getPrefixedId(message, callback) {
  const prefixedMessage = `${ERROR_PREFIX}${message}`;
  if (typeof callback === "function") {
    return callback(prefixedMessage);
  }
  return prefixedMessage;
}
function normalizeError(error, { name, intlMessagePrefixCallback }) {
  const { message } = error;
  const normalizedError = {
    id: getPrefixedId(message, intlMessagePrefixCallback),
    defaultMessage: message,
    name: error.name ?? name,
    values: {}
  };
  if ("path" in error) {
    normalizedError.values = { path: error.path.join(".") };
  }
  return normalizedError;
}
const validateErrorIsYupValidationError = (err) => typeof err.details === "object" && err.details !== null && "errors" in err.details;
function normalizeAPIError(apiError, intlMessagePrefixCallback) {
  var _a;
  const error = (_a = apiError.response) == null ? void 0 : _a.data.error;
  if (error) {
    if (validateErrorIsYupValidationError(error)) {
      return {
        name: error.name,
        message: (error == null ? void 0 : error.message) || null,
        errors: error.details.errors.map(
          (err) => normalizeError(err, { name: error.name, intlMessagePrefixCallback })
        )
      };
    }
    return normalizeError(error, { intlMessagePrefixCallback });
  }
  return null;
}
function useAPIErrorHandler(intlMessagePrefixCallback) {
  const { formatMessage } = useIntl();
  return {
    formatAPIError(error) {
      try {
        const formattedErr = formatAPIError(error, { intlMessagePrefixCallback, formatMessage });
        if (!formattedErr) {
          return formatAxiosError(error, { intlMessagePrefixCallback, formatMessage });
        }
        return formattedErr;
      } catch (_) {
        throw new Error("formatAPIError: Unknown error:", error);
      }
    }
  };
}
function formatAxiosError(error, { intlMessagePrefixCallback, formatMessage }) {
  const { code, message } = error;
  return formatMessage(
    {
      id: getPrefixedId(message, intlMessagePrefixCallback),
      defaultMessage: message
    },
    {
      code
    }
  );
}
function formatAPIError(error, { formatMessage, intlMessagePrefixCallback }) {
  if (!formatMessage) {
    throw new Error("The formatMessage callback is a mandatory argument.");
  }
  const normalizedError = normalizeAPIError(error, intlMessagePrefixCallback);
  if (!normalizedError) {
    return null;
  }
  if ("message" in normalizedError && normalizedError.message !== null) {
    return normalizedError.message;
  }
  if ("errors" in normalizedError) {
    return normalizedError.errors.map(({ id, defaultMessage, values }) => formatMessage({ id, defaultMessage }, values)).join("\n");
  }
  return formatMessage(normalizedError);
}
const useClipboard = () => {
  const copy = useCallback(async (value) => {
    try {
      if (typeof value !== "string" && typeof value !== "number") {
        throw new Error(`Cannot copy typeof ${typeof value} to clipboard, must be a string`);
      } else if (value === "") {
        throw new Error(`Cannot copy empty string to clipboard.`);
      }
      const stringifiedValue = value.toString();
      await navigator.clipboard.writeText(stringifiedValue);
      return true;
    } catch (error) {
      if (process.env.NODE_ENV === "development") {
        console.warn("Copy failed", error);
      }
      return false;
    }
  }, []);
  return { copy };
};
const cache = /* @__PURE__ */ new Map();
function useCollator(locale, options) {
  const cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  if (cache.has(cacheKey)) {
    return cache.get(cacheKey);
  }
  const formatter = new Intl.Collator(locale, options);
  cache.set(cacheKey, formatter);
  return formatter;
}
const useFetchClient = () => {
  const controller = useRef(null);
  if (controller.current === null) {
    controller.current = new AbortController();
  }
  useEffect(() => {
    return () => {
      controller.current.abort();
    };
  }, []);
  return useMemo(
    () => getFetchClient({
      signal: controller.current.signal
    }),
    []
  );
};
function useFilter(locale, options) {
  const collator = useCollator(locale, {
    usage: "search",
    ...options
  });
  return {
    startsWith(string, substring) {
      if (substring.length === 0) {
        return true;
      }
      string = string.normalize("NFC");
      substring = substring.normalize("NFC");
      return collator.compare(string.slice(0, substring.length), substring) === 0;
    },
    endsWith(string, substring) {
      if (substring.length === 0) {
        return true;
      }
      string = string.normalize("NFC");
      substring = substring.normalize("NFC");
      return collator.compare(string.slice(-substring.length), substring) === 0;
    },
    includes(string, substring) {
      if (substring.length === 0) {
        return true;
      }
      string = string.normalize("NFC");
      substring = substring.normalize("NFC");
      let scan = 0;
      const sliceLen = substring.length;
      for (; scan + sliceLen <= string.length; scan++) {
        const slice = string.slice(scan, scan + sliceLen);
        if (collator.compare(substring, slice) === 0) {
          return true;
        }
      }
      return false;
    }
  };
}
const useFocusWhenNavigate = ({
  selector = "main",
  dependencies = []
} = {}) => {
  React.useEffect(() => {
    const mainElement = document.querySelector(selector);
    if (mainElement) {
      mainElement.focus();
      window.scrollTo({ top: 0 });
    } else {
      console.warn(
        `[useFocusWhenNavigate] The page does not contain the selector "${selector}" and can't be focused.`
      );
    }
  }, dependencies);
};
const useLockScroll = ({ lockScroll }) => {
  React.useEffect(() => {
    if (lockScroll) {
      document.body.classList.add("lock-body-scroll");
    }
    return () => {
      document.body.classList.remove("lock-body-scroll");
    };
  }, [lockScroll]);
};
const usePersistentState = (key, defaultValue) => {
  const [value, setValue] = useState(() => {
    const stickyValue = window.localStorage.getItem(key);
    if (stickyValue !== null) {
      try {
        return JSON.parse(stickyValue);
      } catch {
        return stickyValue;
      }
    }
    return defaultValue;
  });
  useEffect(() => {
    window.localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);
  return [value, setValue];
};
const useRBAC = (permissionsToCheck, passedPermissions) => {
  const [internalIsLoading, setInternalIsLoading] = useState(false);
  const defaultAllowedActions = useMemo(
    () => Object.keys(permissionsToCheck).map((name) => ({
      name,
      hasPermission: false
    })),
    [permissionsToCheck]
  );
  const { allPermissions } = useRBACProvider();
  const { post } = useFetchClient();
  const userPermissions = passedPermissions || allPermissions;
  const permissionsToCheckEntries = Object.entries(permissionsToCheck);
  const queryResults = useQueries(
    permissionsToCheckEntries.map(([name, permissions]) => ({
      queryKey: ["useRBAC", name, permissions, userPermissions],
      async queryFn() {
        if (!permissions || !permissions.length) {
          return { name, hasPermission: true };
        }
        if (!userPermissions)
          return;
        const matchingPermissions = userPermissions.filter((value) => {
          const associatedPermission = permissions.find(
            (perm) => perm.action === value.action && perm.subject === value.subject
          );
          return associatedPermission !== void 0;
        });
        if (matchingPermissions.length > 0 && matchingPermissions.every(
          (permission) => Array.isArray(permission.conditions) && permission.conditions.length > 0
        )) {
          try {
            const {
              data: { data: data2 }
            } = await post("/admin/permissions/check", {
              permissions: matchingPermissions.map(({ action, subject }) => ({
                action,
                subject
              }))
            });
            return { name, hasPermission: Array.isArray(data2) && data2.every((v) => v === true) };
          } catch (err) {
            return { name, hasPermission: false };
          }
        }
        return { name, hasPermission: matchingPermissions.length > 0 };
      }
    }))
  );
  const setIsLoading = useCallback(() => {
    setInternalIsLoading(true);
  }, []);
  const isLoading = internalIsLoading || queryResults.some((res) => res.isLoading);
  const data = queryResults.map((res) => res.data);
  const allowedActions = (data.some((res) => res === void 0) ? defaultAllowedActions : data).reduce((acc, permission) => {
    if (!permission)
      return acc;
    const { name, hasPermission } = permission;
    acc[`can${capitalize(name)}`] = hasPermission;
    return acc;
  }, {});
  return { allowedActions, isLoading, setIsLoading };
};
const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const useSelectionState = (keys2, initialValue) => {
  const [selections, setSelections] = useState(initialValue);
  const selectOne = (selection) => {
    const index = selections.findIndex(
      (currentSelection) => keys2.every((key) => currentSelection[key] === selection[key])
    );
    if (index > -1) {
      setSelections((prevSelected) => [
        ...prevSelected.slice(0, index),
        ...prevSelected.slice(index + 1)
      ]);
    } else {
      setSelections((prevSelected) => [...prevSelected, selection]);
    }
  };
  const selectAll = (nextSelections) => {
    if (selections.length > 0) {
      setSelections([]);
    } else {
      setSelections(nextSelections);
    }
  };
  const selectOnly = (nextSelection) => {
    if (selections.indexOf(nextSelection) > -1) {
      setSelections([]);
    } else {
      setSelections([nextSelection]);
    }
  };
  const selectMultiple = (nextSelections) => {
    setSelections((currSelections) => [
      // already selected items
      ...currSelections,
      // filter out already selected items from nextSelections
      ...nextSelections.filter(
        (nextSelection) => currSelections.findIndex(
          (currentSelection) => keys2.every((key) => currentSelection[key] === nextSelection[key])
        ) === -1
      )
    ]);
  };
  const deselectMultiple = (nextSelections) => {
    setSelections((currSelections) => [
      // filter out items in currSelections that are in nextSelections
      ...currSelections.filter(
        (currentSelection) => nextSelections.findIndex(
          (nextSelection) => keys2.every((key) => currentSelection[key] === nextSelection[key])
        ) === -1
      )
    ]);
  };
  return [
    selections,
    { selectOne, selectAll, selectOnly, selectMultiple, deselectMultiple, setSelections }
  ];
};
const StyledIconButton = styled(IconButton)(
  ({ theme }) => `
  border-radius: ${pxToRem(30)};
  width: ${pxToRem(20)};
  height: ${pxToRem(20)};
  padding: ${pxToRem(3)};
  align-items: center;
  justify-content: center;
  svg {
    width: ${pxToRem(8)};
    rect {
      fill: ${theme.colors.primary600}
    }
  }
`
);
const RemoveRoundedButton = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(StyledIconButton, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Minus, {}), ...props });
const defaultFields = ["createdBy", "updatedBy", "publishedAt", "id", "_id"];
const contentManagementUtilRemoveFieldsFromData = (data, contentTypeSchema, componentSchema, fields = defaultFields) => {
  const recursiveCleanData = (data2, schema) => {
    return Object.keys(data2).reduce((acc, current) => {
      const attrType = getType(schema, current);
      const value = get$2(data2, current);
      const component = getOtherInfos(schema, [current, "component"]);
      const isRepeatable = getOtherInfos(schema, [current, "repeatable"]);
      let timestamps = get$2(schema, ["options", "timestamps"]);
      if (!Array.isArray(timestamps)) {
        timestamps = [];
      }
      if ([...fields, ...timestamps].indexOf(current) !== -1) {
        delete acc[current];
        return acc;
      }
      if (!value) {
        return acc;
      }
      if (attrType === "dynamiczone" && Array.isArray(value)) {
        acc[current] = value.map((componentValue) => {
          const subCleanedData = recursiveCleanData(
            componentValue,
            componentSchema[componentValue.__component]
          );
          return subCleanedData;
        });
        return acc;
      }
      if (attrType === "component") {
        if (isRepeatable && Array.isArray(value)) {
          acc[current] = value.map((compoData) => {
            const subCleanedData = recursiveCleanData(compoData, componentSchema[component]);
            return subCleanedData;
          });
        } else {
          acc[current] = recursiveCleanData(value, componentSchema[component]);
        }
        return acc;
      }
      return acc;
    }, Object.assign({}, data2));
  };
  return recursiveCleanData(data, contentTypeSchema);
};
const formatContentTypeData = (data, ct, composSchema) => {
  const recursiveFormatData = (data2, schema) => {
    return Object.keys(data2).reduce((acc, current) => {
      const type = getType(schema, current);
      const value = get$2(data2, current);
      const compoUid = getOtherInfos(schema, [current, "component"]);
      const isRepeatable = getOtherInfos(schema, [current, "repeatable"]);
      if (type === "json" && value !== void 0) {
        acc[current] = JSON.stringify(value, null, 2);
        return acc;
      }
      if (!value) {
        acc[current] = value;
        return acc;
      }
      if (type === "dynamiczone" && Array.isArray(value)) {
        acc[current] = value.map((componentValue) => {
          const formattedData = recursiveFormatData(
            componentValue,
            composSchema[componentValue.__component]
          );
          return formattedData;
        });
        return acc;
      }
      if (type === "component") {
        let formattedValue;
        if (isRepeatable && Array.isArray(value)) {
          formattedValue = value.map((obj, i) => {
            const newObj = { ...obj, __temp_key__: i };
            return recursiveFormatData(newObj, composSchema[compoUid]);
          });
        } else {
          formattedValue = recursiveFormatData(value, composSchema[compoUid]);
        }
        acc[current] = formattedValue;
        return acc;
      }
      acc[current] = value;
      return acc;
    }, {});
  };
  return recursiveFormatData(data, ct);
};
const to = (promise, errorExt) => {
  return promise.then(function(data) {
    return [null, data];
  }).catch(function(err) {
    if (errorExt) {
      Object.assign(err, errorExt);
    }
    return [err, void 0];
  });
};
var ListCache$2 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$2();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var ListCache$1 = _ListCache, Map$1 = _Map, MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$2(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$1(values) {
  var index = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values[index]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function arraySome$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$1(cache2, key) {
  return cache2.has(key);
}
var _cacheHas = cacheHas$1;
var SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
var root = _root;
var Uint8Array$1 = root.Uint8Array;
var _Uint8Array = Uint8Array$1;
function mapToArray$1(map) {
  var index = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var _setToArray = setToArray$1;
var Symbol$1 = _Symbol, Uint8Array = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag:
      var convert = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$1(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var _arrayPush = arrayPush$1;
var arrayPush = _arrayPush, isArray$5 = isArray_1;
function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$5(object) ? result : arrayPush(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$1;
function arrayFilter$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$1() {
  return [];
}
var stubArray_1 = stubArray$1;
var arrayFilter = _arrayFilter, stubArray = stubArray_1;
var objectProto$3 = Object.prototype;
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$1;
function baseTimes$1(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$2(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$2;
var baseTimes = _baseTimes, isArguments$1 = isArguments_1, isArray$4 = isArray_1, isBuffer$2 = isBufferExports, isIndex$1 = _isIndex, isTypedArray$2 = isTypedArray_1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$4(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$1(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike = isArrayLike_1;
function keys$3(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var keys_1 = keys$3;
var baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys$2 = keys_1;
function getAllKeys$1(object) {
  return baseGetAllKeys(object, keys$2, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray$3 = isArray_1, isBuffer$1 = isBufferExports, isTypedArray$1 = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$3(object), othIsArr = isArray$3(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike = isObjectLike_1;
function baseIsEqual$3(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);
}
var _baseIsEqual = baseIsEqual$3;
var baseIsEqual$2 = _baseIsEqual;
function isEqual(value, other) {
  return baseIsEqual$2(value, other);
}
var isEqual_1 = isEqual;
const isEqual$1 = /* @__PURE__ */ getDefaultExportFromCjs(isEqual_1);
function arrayEach$1(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$1;
var isObject$3 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$3(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var baseFor = _baseFor, keys$1 = keys_1;
function baseForOwn$1(object, iteratee) {
  return object && baseFor(object, iteratee, keys$1);
}
var _baseForOwn = baseForOwn$1;
var Stack = _Stack, baseIsEqual$1 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(object, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject$2 = isObject_1;
function isStrictComparable$2(value) {
  return value === value && !isObject$2(value);
}
var _isStrictComparable = isStrictComparable$2;
var isStrictComparable$1 = _isStrictComparable, keys = keys_1;
function getMatchData$1(object) {
  var result = keys(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2;
var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath = _castPath, isArguments = isArguments_1, isArray$2 = isArray_1, isIndex = _isIndex, isLength = isLength_1, toKey$2 = _toKey;
function hasPath$1(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey$2(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray$2(object) || isArguments(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn, hasPath = _hasPath;
function hasIn$1(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var hasIn_1 = hasIn$1;
var baseIsEqual = _baseIsEqual, get = get_1, hasIn = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$1 = _toKey;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(path, srcValue) {
  if (isKey$1(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$1(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function identity$1(value) {
  return value;
}
var identity_1 = identity$1;
function baseProperty$1(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var _baseProperty = baseProperty$1;
var baseGet = _baseGet;
function basePropertyDeep$1(path) {
  return function(object) {
    return baseGet(object, path);
  };
}
var _basePropertyDeep = basePropertyDeep$1;
var baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey = _toKey;
function property$1(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
var property_1 = property$1;
var baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity = identity_1, isArray$1 = isArray_1, property = property_1;
function baseIteratee$1(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var _baseIteratee = baseIteratee$1;
var overArg = _overArg;
var getPrototype$1 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$1;
var arrayEach = _arrayEach, baseCreate = _baseCreate, baseForOwn = _baseForOwn, baseIteratee = _baseIteratee, getPrototype = _getPrototype, isArray = isArray_1, isBuffer = isBufferExports, isFunction = isFunction_1, isObject$1 = isObject_1, isTypedArray = isTypedArray_1;
function transform(object, iteratee, accumulator) {
  var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
  iteratee = baseIteratee(iteratee);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject$1(object)) {
      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
    return iteratee(accumulator, value, index, object2);
  });
  return accumulator;
}
var transform_1 = transform;
const transform$1 = /* @__PURE__ */ getDefaultExportFromCjs(transform_1);
function difference(object, base) {
  function changes(object2, base2) {
    return transform$1(object2, (result, value, key) => {
      if (!isEqual$1(value, base2[key])) {
        result[key] = isObject$7(value) && isObject$7(base2[key]) ? changes(value, base2[key]) : value;
      }
      return result;
    });
  }
  return changes(object, base);
}
/**
 *
 * Returns a normalized error message
 *
 * @deprecated
 * @preserve
 */
function getAPIInnerErrors(error, { getTrad }) {
  const normalizedError = normalizeAPIError(error, getTrad);
  if (normalizedError && "errors" in normalizedError) {
    return normalizedError.errors.reduce((acc, error2) => {
      if ("path" in error2.values) {
        acc[error2.values.path] = {
          id: error2.id,
          defaultMessage: error2.defaultMessage
        };
      }
      return acc;
    }, {});
  }
  return normalizedError == null ? void 0 : normalizedError.defaultMessage;
}
const getFileExtension = (ext) => ext && ext[0] === "." ? ext.substr(1) : ext;
const extractValuesFromYupError = (errorType, errorParams) => {
  if (!errorType || !errorParams) {
    return {};
  }
  return {
    [errorType]: errorParams[errorType]
  };
};
const getYupInnerErrors = (error) => ((error == null ? void 0 : error.inner) || []).reduce((acc, currentError) => {
  if (currentError.path) {
    acc[currentError.path.split("[").join(".").split("]").join("")] = {
      id: currentError.message,
      defaultMessage: currentError.message,
      values: extractValuesFromYupError(currentError == null ? void 0 : currentError.type, currentError == null ? void 0 : currentError.params)
    };
  }
  return acc;
}, {});
const prefixFileUrlWithBackendUrl = (fileURL) => {
  return !!fileURL && fileURL.startsWith("/") ? `${window.strapi.backendURL}${fileURL}` : fileURL;
};
const prefixPluginTranslations = (trad, pluginId) => {
  if (!pluginId) {
    throw new TypeError("pluginId can't be empty");
  }
  return Object.keys(trad).reduce((acc, current) => {
    acc[`${pluginId}.${current}`] = trad[current];
    return acc;
  }, {});
};
function baseClamp$1(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var _baseClamp = baseClamp$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim, isObject = isObject_1, isSymbol = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var toNumber = toNumber_1;
var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_1 = toFinite$1;
var toFinite = toFinite_1;
function toInteger$1(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger$1;
var baseClamp = _baseClamp, baseToString = _baseToString, toInteger = toInteger_1, toString = toString_1;
function startsWith(string, target, position) {
  string = toString(string);
  position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
  target = baseToString(target);
  return string.slice(position, position + target.length) == target;
}
var startsWith_1 = startsWith;
const startsWith$1 = /* @__PURE__ */ getDefaultExportFromCjs(startsWith_1);
async function parseJSON(response) {
  if (response instanceof Response) {
    return response.json();
  }
  return response;
}
async function checkStatus(response, checkToken = true) {
  if (response.status >= 200 && response.status < 300 || response.status === 0) {
    return response;
  }
  if (response.status === 401 && auth.getToken() && checkToken) {
    auth.clearAppStorage();
    window.location.reload();
  }
  return parseJSON(response).then((responseFormatted) => {
    const error = new Error(response.statusText);
    error.response = response;
    error.response.payload = responseFormatted;
    throw error;
  }).catch(() => {
    const error = new Error(response.statusText);
    error.response = response;
    throw error;
  });
}
function formatQueryParams(params) {
  return Object.keys(params).map((k) => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`).join("&");
}
async function serverRestartWatcher(response) {
  return new Promise((resolve) => {
    fetch(`${window.strapi.backendURL}/_health`, {
      method: "HEAD",
      mode: "no-cors",
      keepalive: false,
      headers: {
        "Content-Type": "application/json"
      }
    }).then((res) => {
      if (res.status >= 400) {
        throw new Error("not available");
      }
      resolve(response);
    }).catch(() => {
      setTimeout(() => {
        return serverRestartWatcher(response).then(resolve);
      }, 100);
    });
  });
}
const warnOnce = once(console.warn);
async function request(url, options = {}, shouldWatchServerRestart, stringify2 = true, { noAuth } = { noAuth: false }) {
  warnOnce(
    "The `request` function is deprecated and will be removed in the next major version. Please use `useFetchClient` instead."
  );
  if (!options.headers) {
    options.headers = Object.assign(
      {
        "Content-Type": "application/json"
      },
      options.headers
    );
  }
  const token = auth.getToken();
  if (token && !noAuth) {
    options.headers = Object.assign(
      {
        Authorization: `Bearer ${token}`
      },
      options.headers
    );
  }
  url = startsWith$1(url, "/") ? `${window.strapi.backendURL}${url}` : url;
  if (options && options.params) {
    const params = formatQueryParams(options.params);
    url = `${url}?${params}`;
  }
  if (options && options.body && stringify2) {
    options.body = JSON.stringify(options.body);
  }
  return fetch(url, options).then(checkStatus).then(parseJSON).then((response) => {
    if (shouldWatchServerRestart) {
      return serverRestartWatcher(response);
    }
    return response;
  });
}
const setHexOpacity = (hex, alpha) => `${hex}${Math.floor(alpha * 255).toString(16).padStart(2, "0")}`;
const stopPropagation = {
  onClick: (e) => e.stopPropagation(),
  role: "button",
  "aria-hidden": true
};
const onRowClick = ({ fn, condition = true }) => {
  if (condition) {
    return {
      style: { cursor: "pointer" },
      onClick: fn
    };
  }
};
const StopPropagation = () => {
  return React.createElement("div", stopPropagation);
};
const errorsTrads = {
  email: "components.Input.error.validation.email",
  json: "components.Input.error.validation.json",
  lowercase: "components.Input.error.validation.lowercase",
  max: "components.Input.error.validation.max",
  maxLength: "components.Input.error.validation.maxLength",
  min: "components.Input.error.validation.min",
  minLength: "components.Input.error.validation.minLength",
  regex: "components.Input.error.validation.regex",
  required: "components.Input.error.validation.required",
  unique: "components.Input.error.validation.unique",
  integer: "component.Input.error.validation.integer"
};
function wrapAxiosInstance(instance2) {
  const isDevelopmentEnv = process.env.NODE_ENV === "development";
  const warn = () => {
    if (!isDevelopmentEnv)
      return;
    console.warn(
      'Deprecation warning: Usage of "axiosInstance" utility is deprecated and will be removed in the next major release. Instead, use the useFetchClient() hook, which is exported from the helper-plugin: { useFetchClient } from "@strapi/helper-plugin"'
    );
  };
  const wrapper = {
    request: (...args) => {
      warn();
      return instance2.request(...args);
    },
    get: (...args) => {
      warn();
      return instance2.get(...args);
    },
    head: (...args) => {
      warn();
      return instance2.head(...args);
    },
    delete: (...args) => {
      warn();
      return instance2.delete(...args);
    },
    options: (...args) => {
      warn();
      return instance2.options(...args);
    },
    post: (...args) => {
      warn();
      return instance2.post(...args);
    },
    put: (...args) => {
      warn();
      return instance2.put(...args);
    },
    patch: (...args) => {
      warn();
      return instance2.patch(...args);
    },
    getUri: (...args) => {
      warn();
      return instance2.getUri(...args);
    }
  };
  return wrapper;
}
export {
  AnErrorOccurred,
  AppInfoContext,
  AppInfoProvider,
  AppInfosContext,
  AppInfosProvider,
  AutoReloadOverlayBlockerContext,
  AutoReloadOverlayBlockerProvider,
  Body$1 as Body,
  CheckPagePermissions,
  CheckPermissions,
  ConfirmDialog,
  ContentBox,
  ContentManagerEditViewDataManagerContext,
  CustomFieldsContext,
  CustomFieldsProvider,
  DateTimePickerLegacy as DateTimePicker,
  Table$1 as DynamicTable,
  EmptyBodyTable,
  EmptyStateLayout,
  FilterListURLQuery,
  FilterPopoverURLQuery,
  Form,
  GenericInput,
  GuidedTourContext,
  GuidedTourProvider,
  InjectionZone,
  LibraryContext,
  LibraryProvider,
  Link,
  LinkButton,
  LoadingIndicatorPage,
  NoContent,
  NoMedia,
  NoPermissions,
  NotAllowedInput,
  NotificationsContext,
  NotificationsProvider,
  OverlayBlockerContext,
  OverlayBlockerProvider,
  PageSizeURLQuery,
  PaginationURLQuery,
  RBACContext,
  RBACProviderContext,
  ReactSelect,
  RelativeTime,
  RemoveRoundedButton,
  Root$1 as Root,
  SearchURLQuery,
  SettingsPageTitle,
  SortIcon,
  Status,
  StopPropagation,
  StrapiAppContext,
  StrapiAppProvider,
  Table,
  TrackingContext,
  TrackingProvider,
  auth,
  contentManagementUtilRemoveFieldsFromData,
  difference,
  findMatchingPermissions,
  formatContentTypeData,
  getAPIInnerErrors,
  getFetchClient,
  getFileExtension,
  getOtherInfos,
  getType,
  getYupInnerErrors,
  hasPermissions,
  normalizeAPIError,
  onRowClick,
  prefixFileUrlWithBackendUrl,
  prefixPluginTranslations,
  pxToRem,
  request,
  setHexOpacity,
  stopPropagation,
  to,
  errorsTrads as translatedErrors,
  useAPIErrorHandler,
  useAppInfo,
  useAppInfos,
  useAutoReloadOverlayBlocker,
  useCMEditViewDataManager,
  useCallbackRef,
  useClipboard,
  useCollator,
  useCustomFields,
  useFetchClient,
  useFilter,
  useFocusInputField,
  useFocusWhenNavigate,
  useGuidedTour,
  useLibrary,
  useLockScroll,
  useNotification,
  useOverlayBlocker,
  usePersistentState,
  useQuery,
  useQueryParams,
  useRBAC,
  useRBACProvider,
  useSelectionState,
  useStrapiApp,
  useTableContext,
  useTracking,
  wrapAxiosInstance
};
//# sourceMappingURL=index.mjs.map

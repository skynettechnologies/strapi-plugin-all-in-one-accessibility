import { jsx as f, jsxs as Me, Fragment as Oe } from "react/jsx-runtime";
import * as l from "react";
import { useComposedRefs as _ } from "@radix-ui/react-compose-refs";
import { createContextScope as st, createContext as ct } from "@radix-ui/react-context";
import { Slot as Ve } from "@radix-ui/react-slot";
import { composeEventHandlers as T } from "@radix-ui/primitive";
import { composeEventHandlers as _n } from "@radix-ui/primitive";
import { DismissableLayer as it } from "@radix-ui/react-dismissable-layer";
import { useFocusGuards as at } from "@radix-ui/react-focus-guards";
import { FocusScope as ut } from "@radix-ui/react-focus-scope";
import { useId as ne } from "@radix-ui/react-id";
import * as re from "@radix-ui/react-popper";
import { createPopperScope as dt } from "@radix-ui/react-popper";
import { Portal as pt } from "@radix-ui/react-portal";
import { Primitive as N } from "@radix-ui/react-primitive";
import { useControllableState as ce } from "@radix-ui/react-use-controllable-state";
import { useLayoutEffect as L } from "@radix-ui/react-use-layout-effect";
import { hideOthers as ft } from "aria-hidden";
import * as Ce from "react-dom";
import { RemoveScroll as mt } from "react-remove-scroll";
import { clamp as rt } from "@radix-ui/number";
import { createCollection as Gt } from "@radix-ui/react-collection";
import { useDirection as jt } from "@radix-ui/react-direction";
import { usePrevious as Yt } from "@radix-ui/react-use-previous";
import { VisuallyHidden as qt } from "@radix-ui/react-visually-hidden";
import { useCallbackRef as Xt } from "@radix-ui/react-use-callback-ref";
import { useCallbackRef as On } from "@radix-ui/react-use-callback-ref";
function Zt(r) {
  const c = `${r}CollectionProvider`, [e, t] = st(c), [o, n] = e(c, {
    collectionRef: { current: null },
    itemMap: /* @__PURE__ */ new Map(),
    listeners: /* @__PURE__ */ new Set()
  }), i = (u) => {
    const { scope: h, children: v } = u, C = l.useRef(null), b = l.useRef(/* @__PURE__ */ new Map()).current, g = l.useRef(/* @__PURE__ */ new Set()).current;
    return /* @__PURE__ */ f(o, { scope: h, itemMap: b, collectionRef: C, listeners: g, children: v });
  };
  i.displayName = c;
  const s = `${r}CollectionSlot`, a = l.forwardRef((u, h) => {
    const { scope: v, children: C } = u, b = n(s, v), g = _(h, b.collectionRef);
    return /* @__PURE__ */ f(Ve, { ref: g, children: C });
  });
  a.displayName = s;
  const m = `${r}CollectionItemSlot`, d = "data-radix-collection-item", x = l.forwardRef((u, h) => {
    const { scope: v, children: C, ...b } = u, g = l.useRef(null), I = _(h, g), E = n(m, v);
    return l.useEffect(() => {
      const M = Array.from(E.itemMap.values());
      return E.itemMap.set(g, { ref: g, ...b }), E.listeners.forEach((R) => R(Array.from(E.itemMap.values()), M)), () => {
        const R = Array.from(E.itemMap.values());
        E.itemMap.delete(g), E.listeners.forEach((A) => A(Array.from(E.itemMap.values()), R));
      };
    }), /* @__PURE__ */ f(Ve, { [d]: "", ref: I, children: C });
  });
  x.displayName = m;
  function p(u) {
    const h = n(`${r}CollectionConsumer`, u), v = l.useCallback(() => {
      const b = h.collectionRef.current;
      if (!b)
        return [];
      const g = Array.from(b.querySelectorAll(`[${d}]`));
      return Array.from(h.itemMap.values()).sort(
        (M, R) => g.indexOf(M.ref.current) - g.indexOf(R.ref.current)
      );
    }, [h.collectionRef, h.itemMap]), C = l.useCallback(
      (b) => (h.listeners.add(b), () => h.listeners.delete(b)),
      [h.listeners]
    );
    return { getItems: v, subscribe: C };
  }
  return [
    { Provider: i, Slot: a, ItemSlot: x },
    p,
    t
  ];
}
const Te = /* @__PURE__ */ new Map();
function Jt(r, c) {
  const e = r + (c ? Object.entries(c).sort((o, n) => o[0] < n[0] ? -1 : 1).join() : "");
  if (Te.has(e))
    return Te.get(e);
  const t = new Intl.Collator(r, c);
  return Te.set(e, t), t;
}
function De(r, c) {
  const e = Jt(r, {
    usage: "search",
    ...c
  });
  return {
    startsWith(t, o) {
      return o.length === 0 ? !0 : (t = t.normalize("NFC"), o = o.normalize("NFC"), e.compare(t.slice(0, o.length), o) === 0);
    },
    endsWith(t, o) {
      return o.length === 0 ? !0 : (t = t.normalize("NFC"), o = o.normalize("NFC"), e.compare(t.slice(-o.length), o) === 0);
    },
    contains(t, o) {
      if (o.length === 0)
        return !0;
      t = t.normalize("NFC"), o = o.normalize("NFC");
      let n = 0;
      const i = o.length;
      for (; n + i <= t.length; n++) {
        const s = t.slice(n, n + i);
        if (e.compare(o, s) === 0)
          return !0;
      }
      return !1;
    }
  };
}
const Qt = (r) => {
  const c = l.useRef();
  return l.useEffect(() => {
    c.current = r;
  }), c.current;
}, eo = [" ", "Enter", "ArrowUp", "ArrowDown"], to = ["Enter"], oo = (r) => !!(r.length === 1 && r.match(/\S| /)), ht = "Combobox", [ie, me] = Zt(ht), [no, K] = ct(ht), ro = ({ children: r }) => /* @__PURE__ */ f(re.Root, { children: /* @__PURE__ */ f(ie.Provider, { scope: void 0, children: r }) }), lo = (r) => typeof r == "string" ? r === "none" ? {
  type: r,
  filter: void 0
} : {
  type: r,
  filter: "startsWith"
} : r, so = (r) => {
  const {
    allowCustomValue: c = !1,
    autocomplete: e = "none",
    children: t,
    open: o,
    defaultOpen: n,
    onOpenChange: i,
    value: s,
    defaultValue: a,
    onValueChange: m,
    disabled: d,
    required: x = !1,
    locale: p = "en-EN",
    onTextValueChange: u,
    textValue: h,
    defaultTextValue: v,
    filterValue: C,
    defaultFilterValue: b,
    onFilterValueChange: g,
    isPrintableCharacter: I = oo
  } = r, [E, M] = l.useState(null), [R, A] = l.useState(null), [k, X] = l.useState(null), [z, B] = l.useState(null), [O = !1, H] = ce({
    prop: o,
    defaultProp: n,
    onChange: i
  }), [F, G] = ce({
    prop: s,
    defaultProp: a,
    onChange: m
  }), [j, $] = ce({
    prop: h,
    defaultProp: c && !v ? s : v,
    onChange: u
  }), [Z, U] = ce({
    prop: C,
    defaultProp: b,
    onChange: g
  }), ue = ne(), le = l.useCallback(
    (pe, W) => {
      const se = W.map((S) => S.ref.current), [Q, ...y] = se, [V] = y.slice(-1), D = z ?? W.find((S) => S.value === F)?.ref.current;
      for (const S of pe) {
        if (S === D)
          return;
        if (S?.scrollIntoView({ block: "nearest" }), S === Q && R && (R.scrollTop = 0), S === V && R && (R.scrollTop = R.scrollHeight), B(S), e === "both") {
          const w = W.find((P) => P.ref.current === S);
          w && $(w.textValue);
        }
        if (S !== D)
          return;
      }
    },
    [e, $, R, z, F]
  ), de = lo(e);
  return l.useEffect(() => {
    e !== "both" && B(null);
  }, [j, e]), l.useEffect(() => {
    if (k && E)
      return ft([k, E]);
  }, [k, E]), /* @__PURE__ */ f(ro, { children: /* @__PURE__ */ f(
    no,
    {
      allowCustomValue: c,
      autocomplete: de,
      required: x,
      trigger: E,
      onTriggerChange: M,
      contentId: ue,
      value: F,
      onValueChange: G,
      open: O,
      onOpenChange: H,
      disabled: d,
      locale: p,
      focusFirst: le,
      textValue: j,
      onTextValueChange: $,
      onViewportChange: A,
      onContentChange: X,
      visuallyFocussedItem: z,
      filterValue: Z,
      onFilterValueChange: U,
      onVisuallyFocussedItemChange: B,
      isPrintableCharacter: I,
      children: t
    }
  ) });
}, gt = "ComboboxTrigger", xt = l.forwardRef((r, c) => {
  const { ...e } = r, t = K(gt), o = () => {
    t.disabled || t.onOpenChange(!0);
  };
  return /* @__PURE__ */ f(re.Anchor, { asChild: !0, children: /* @__PURE__ */ f(
    ut,
    {
      asChild: !0,
      trapped: t.open,
      onMountAutoFocus: (n) => {
        n.preventDefault();
      },
      onUnmountAutoFocus: (n) => {
        t.trigger?.focus({ preventScroll: !0 }), document.getSelection()?.empty(), n.preventDefault();
      },
      children: /* @__PURE__ */ f(
        "div",
        {
          ref: c,
          "data-disabled": t.disabled ? "" : void 0,
          ...e,
          onClick: T(e.onClick, () => {
            t.trigger?.focus();
          }),
          onPointerDown: T(e.onPointerDown, (n) => {
            const i = n.target;
            i.hasPointerCapture(n.pointerId) && i.releasePointerCapture(n.pointerId), (i.closest("button") ?? i.closest("div")) === n.currentTarget && n.button === 0 && n.ctrlKey === !1 && (o(), t.trigger?.focus());
          })
        }
      )
    }
  ) });
});
xt.displayName = gt;
const Ct = "ComboboxInput", vt = l.forwardRef((r, c) => {
  const e = K(Ct), t = l.useRef(null), { getItems: o } = me(void 0), { startsWith: n } = De(e.locale, { sensitivity: "base" }), i = e.disabled, s = _(t, c, e.onTriggerChange), a = () => {
    i || e.onOpenChange(!0);
  }, m = Qt(e.filterValue);
  return L(() => {
    const d = setTimeout(() => {
      if (e.textValue === "" || e.textValue === void 0 || e.filterValue === "" || e.filterValue === void 0)
        return;
      const x = o().find(
        (u) => u.type === "option" && n(u.textValue, e.textValue)
      ), p = So(m ?? "", e.filterValue);
      x && !e.visuallyFocussedItem && p === e.filterValue.length && t.current?.setSelectionRange(e.filterValue.length, e.textValue.length);
    });
    return () => clearTimeout(d);
  }, [e.textValue, e.filterValue, n, e.visuallyFocussedItem, o, m]), /* @__PURE__ */ f(
    "input",
    {
      type: "text",
      role: "combobox",
      "aria-controls": e.contentId,
      "aria-expanded": e.open,
      "aria-required": e.required,
      "aria-autocomplete": e.autocomplete.type,
      "data-state": e.open ? "open" : "closed",
      "aria-disabled": i,
      "aria-activedescendant": e.visuallyFocussedItem?.id,
      disabled: i,
      "data-disabled": i ? "" : void 0,
      "data-placeholder": e.textValue === void 0 ? "" : void 0,
      value: e.textValue ?? "",
      ...r,
      ref: s,
      onKeyDown: T(r.onKeyDown, (d) => {
        if (["ArrowUp", "ArrowDown", "Home", "End"].includes(d.key))
          e.open || a(), setTimeout(() => {
            let p = o().filter((u) => !u.disabled && u.isVisible).map((u) => u.ref.current);
            if (["ArrowUp", "End"].includes(d.key) && (p = p.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(d.key)) {
              const u = e.visuallyFocussedItem ?? o().find((h) => h.value === e.value)?.ref.current;
              if (u) {
                let h = p.indexOf(u);
                h === p.length - 1 && (h = -1), p = p.slice(h + 1);
              }
            }
            if (["ArrowDown"].includes(d.key) && e.autocomplete.type === "both" && p.length > 1) {
              const [u, ...h] = p, v = o().find((C) => C.ref.current === u).textValue;
              e.textValue === v && (p = h);
            }
            e.focusFirst(p, o());
          }), d.preventDefault();
        else if (["Tab"].includes(d.key) && e.open)
          d.preventDefault();
        else if (["Escape"].includes(d.key))
          e.open ? e.onOpenChange(!1) : (e.onValueChange(void 0), e.onTextValueChange("")), d.preventDefault();
        else if (to.includes(d.key)) {
          if (e.visuallyFocussedItem) {
            const x = o().find((p) => p.ref.current === e.visuallyFocussedItem);
            x && (e.onValueChange(x.value), e.onTextValueChange(x.textValue), e.autocomplete.type === "both" && e.onFilterValueChange(x.textValue), x.ref.current?.click());
          } else {
            const x = o().find(
              (p) => p.type === "option" && !p.disabled && p.textValue === e.textValue
            );
            x && (e.onValueChange(x.value), e.onTextValueChange(x.textValue), e.autocomplete.type === "both" && e.onFilterValueChange(x.textValue), x.ref.current?.click());
          }
          e.onOpenChange(!1), d.preventDefault();
        } else
          e.onVisuallyFocussedItemChange(null);
      }),
      onChange: T(r.onChange, (d) => {
        e.onTextValueChange(d.currentTarget.value), e.autocomplete.type === "both" && e.onFilterValueChange(d.currentTarget.value);
      }),
      onKeyUp: T(r.onKeyUp, (d) => {
        if (!e.open && (e.isPrintableCharacter(d.key) || ["Backspace"].includes(d.key)) && a(), setTimeout(() => {
          if (e.autocomplete.type === "both" && e.isPrintableCharacter(d.key) && e.filterValue !== void 0) {
            const x = e.filterValue, p = o().find((u) => n(u.textValue, x));
            p && e.onTextValueChange(p.textValue);
          }
        }), e.autocomplete.type === "none" && e.isPrintableCharacter(d.key)) {
          const x = e.textValue ?? "", p = o().find((u) => n(u.textValue, x));
          p && (e.onVisuallyFocussedItemChange(p.ref.current), p.ref.current?.scrollIntoView());
        }
      }),
      onBlur: T(r.onBlur, () => {
        if (e.open)
          return;
        e.onVisuallyFocussedItemChange(null);
        const [d] = o().filter(
          (p) => p.textValue === e.textValue && p.type === "option"
        );
        if (d) {
          e.onValueChange(d.value), e.autocomplete.type === "both" && e.onFilterValueChange(d.textValue);
          return;
        }
        if (e.allowCustomValue) {
          e.onValueChange(e.textValue), e.autocomplete.type === "both" && e.onFilterValueChange(e.textValue);
          return;
        }
        const [x] = o().filter((p) => p.value === e.value && p.type === "option");
        x && e.textValue !== "" ? (e.onTextValueChange(x.textValue), e.autocomplete.type === "both" && e.onFilterValueChange(x.textValue)) : (e.onValueChange(void 0), e.onTextValueChange(""));
      })
    }
  );
});
vt.displayName = "ComboboxTextInput";
const bt = l.forwardRef((r, c) => {
  const { children: e, ...t } = r, o = K(Ct), n = o.disabled, i = () => {
    n || (o.onOpenChange(!0), o.trigger?.focus());
  };
  return /* @__PURE__ */ f(
    N.button,
    {
      "aria-hidden": !0,
      type: "button",
      "aria-disabled": n,
      "aria-controls": o.contentId,
      "aria-expanded": o.open,
      disabled: n,
      "data-disabled": n ? "" : void 0,
      ...t,
      tabIndex: -1,
      ref: c,
      onClick: T(t.onClick, () => {
        o.trigger?.focus();
      }),
      onPointerDown: T(t.onPointerDown, (s) => {
        s.button === 0 && s.ctrlKey === !1 && (i(), s.preventDefault());
      }),
      onKeyDown: T(t.onKeyDown, (s) => {
        eo.includes(s.key) && (i(), s.preventDefault());
      }),
      children: e || "▼"
    }
  );
});
bt.displayName = "ComboboxIcon";
const co = "ComboboxPortal", yt = (r) => /* @__PURE__ */ f(pt, { asChild: !0, ...r });
yt.displayName = co;
const ke = "ComboboxContent", St = l.forwardRef((r, c) => {
  const e = K(ke), { getItems: t } = me(void 0), [o, n] = l.useState();
  if (L(() => {
    n(new DocumentFragment());
  }, []), L(() => {
    e.open && e.autocomplete.type === "none" && setTimeout(() => {
      t().find((s) => s.value === e.value)?.ref.current?.scrollIntoView({ block: "nearest" });
    });
  }, [t, e.autocomplete, e.value, e.open]), !e.open) {
    const i = o;
    return i ? Ce.createPortal(
      /* @__PURE__ */ f(ie.Slot, { scope: void 0, children: /* @__PURE__ */ f("div", { children: r.children }) }),
      i
    ) : null;
  }
  return /* @__PURE__ */ f(It, { ...r, ref: c });
});
St.displayName = ke;
const io = 10, It = l.forwardRef(
  (r, c) => {
    const { onEscapeKeyDown: e, onPointerDownOutside: t, ...o } = r, n = K(ke), i = _(c, (a) => n.onContentChange(a)), { onOpenChange: s } = n;
    return at(), l.useEffect(() => {
      const a = () => {
        s(!1);
      };
      return window.addEventListener("blur", a), window.addEventListener("resize", a), () => {
        window.removeEventListener("blur", a), window.removeEventListener("resize", a);
      };
    }, [s]), /* @__PURE__ */ f(mt, { allowPinchZoom: !0, children: /* @__PURE__ */ f(
      it,
      {
        asChild: !0,
        onEscapeKeyDown: e,
        onPointerDownOutside: t,
        onFocusOutside: (a) => {
          a.preventDefault();
        },
        onDismiss: () => {
          n.onOpenChange(!1), n.trigger?.focus({ preventScroll: !0 });
        },
        children: /* @__PURE__ */ f(
          wt,
          {
            role: "listbox",
            id: n.contentId,
            "data-state": n.open ? "open" : "closed",
            onContextMenu: (a) => a.preventDefault(),
            ...o,
            ref: i,
            style: {
              // flex layout so we can place the scroll buttons properly
              display: "flex",
              flexDirection: "column",
              // reset the outline by default as the content MAY get focused
              outline: "none",
              ...o.style
            }
          }
        )
      }
    ) });
  }
);
It.displayName = "ComboboxContentImpl";
const wt = l.forwardRef(
  (r, c) => {
    const { align: e = "start", collisionPadding: t = io, ...o } = r;
    return /* @__PURE__ */ f(
      re.Content,
      {
        ...o,
        ref: c,
        align: e,
        collisionPadding: t,
        style: {
          // Ensure border-box for floating-ui calculations
          boxSizing: "border-box",
          ...o.style,
          "--radix-combobox-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-combobox-content-available-width": "var(--radix-popper-available-width)",
          "--radix-combobox-content-available-height": "var(--radix-popper-available-height)",
          "--radix-combobox-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-combobox-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
wt.displayName = "ComboboxPopperPosition";
const Tt = "ComboboxViewport", Vt = l.forwardRef((r, c) => {
  const e = K(Tt), t = _(c, e.onViewportChange);
  return /* @__PURE__ */ Me(Oe, { children: [
    /* @__PURE__ */ f(
      "style",
      {
        dangerouslySetInnerHTML: {
          __html: "[data-radix-combobox-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-combobox-viewport]::-webkit-scrollbar{display:none}"
        }
      }
    ),
    /* @__PURE__ */ f(ie.Slot, { scope: void 0, children: /* @__PURE__ */ f(
      N.div,
      {
        "data-radix-combobox-viewport": "",
        role: "presentation",
        ...r,
        ref: t,
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: 1,
          overflow: "auto",
          ...r.style
        }
      }
    ) })
  ] });
});
Vt.displayName = Tt;
const ve = "ComboboxItem", [lt, Fe] = ct(ve), Le = l.forwardRef((r, c) => {
  const { value: e, disabled: t = !1, textValue: o, ...n } = r, [i, s] = l.useState();
  L(() => {
    s(new DocumentFragment());
  }, []);
  const { onTextValueChange: a, textValue: m, ...d } = K(ve), x = ne(), [p, u] = l.useState(o ?? ""), h = d.value === e, { startsWith: v, contains: C } = De(d.locale, { sensitivity: "base" }), b = l.useCallback((g) => {
    u((I) => I || (g?.textContent ?? "").trim());
  }, []);
  return l.useEffect(() => {
    h && m === void 0 && p !== "" && a(p);
  }, [p, h, m, a]), d.autocomplete.type === "both" && p && d.filterValue && !v(p, d.filterValue) || d.autocomplete.type === "list" && d.autocomplete.filter === "startsWith" && p && m && !v(p, m) || d.autocomplete.type === "list" && d.autocomplete.filter === "contains" && p && m && !C(p, m) ? i ? Ce.createPortal(
    /* @__PURE__ */ f(
      lt,
      {
        textId: x,
        onTextValueChange: b,
        isSelected: h,
        textValue: p,
        children: /* @__PURE__ */ f(
          ie.ItemSlot,
          {
            scope: void 0,
            value: e,
            textValue: p,
            disabled: t,
            type: "option",
            isVisible: !1,
            children: /* @__PURE__ */ f(Pe, { ref: c, value: e, disabled: t, ...n })
          }
        )
      }
    ),
    i
  ) : null : /* @__PURE__ */ f(
    lt,
    {
      textId: x,
      onTextValueChange: b,
      isSelected: h,
      textValue: p,
      children: /* @__PURE__ */ f(
        ie.ItemSlot,
        {
          scope: void 0,
          value: e,
          textValue: p,
          disabled: t,
          type: "option",
          isVisible: !0,
          children: /* @__PURE__ */ f(Pe, { ref: c, value: e, disabled: t, ...n })
        }
      )
    }
  );
});
Le.displayName = ve;
const Pt = "ComboboxItemImpl", Pe = l.forwardRef((r, c) => {
  const { value: e, disabled: t = !1, ...o } = r, n = l.useRef(null), i = _(c, n), { getItems: s } = me(void 0), { onTextValueChange: a, visuallyFocussedItem: m, ...d } = K(ve), { isSelected: x, textValue: p, textId: u } = Fe(Pt), h = () => {
    t || (d.onValueChange(e), a(p), d.onOpenChange(!1), d.autocomplete.type === "both" && d.onFilterValueChange(p), d.trigger?.focus({ preventScroll: !0 }));
  }, v = l.useMemo(() => m === s().find((b) => b.ref.current === n.current)?.ref.current, [s, m]), C = ne();
  return /* @__PURE__ */ f(
    N.div,
    {
      role: "option",
      "aria-labelledby": u,
      "data-highlighted": v ? "" : void 0,
      "aria-selected": x && v,
      "data-state": x ? "checked" : "unchecked",
      "aria-disabled": t || void 0,
      "data-disabled": t ? "" : void 0,
      tabIndex: t ? void 0 : -1,
      ...o,
      id: C,
      ref: i,
      onPointerUp: T(o.onPointerUp, h)
    }
  );
});
Pe.displayName = Pt;
const Et = "ComboboxItemText", Nt = l.forwardRef((r, c) => {
  const { className: e, style: t, ...o } = r, n = Fe(Et), i = _(c, n.onTextValueChange);
  return /* @__PURE__ */ f(N.span, { id: n.textId, ...o, ref: i });
});
Nt.displayName = Et;
const Rt = "ComboboxItemIndicator", At = l.forwardRef((r, c) => {
  const { isSelected: e } = Fe(Rt);
  return e ? /* @__PURE__ */ f(N.span, { "aria-hidden": !0, ...r, ref: c }) : null;
});
At.displayName = Rt;
const Be = "ComboboxNoValueFound", _t = l.forwardRef((r, c) => {
  const { textValue: e = "", filterValue: t = "", locale: o, autocomplete: n } = K(Be), [i, s] = l.useState([]), { subscribe: a } = me(void 0), { startsWith: m, contains: d } = De(o, { sensitivity: "base" });
  return l.useEffect(() => {
    const x = a((p) => {
      s(p);
    });
    return () => {
      x();
    };
  }, [a]), i.length === 0 || n.type === "none" || n.type === "list" && n.filter === "startsWith" && i.some((x) => m(x.textValue, e)) || n.type === "both" && i.some((x) => m(x.textValue, t)) || n.type === "list" && n.filter === "contains" && i.some((x) => d(x.textValue, e)) ? null : /* @__PURE__ */ f(N.div, { ...r, ref: c });
});
_t.displayName = Be;
const Mt = l.forwardRef((r, c) => {
  const { disabled: e = !1, ...t } = r, o = K(Be), { textValue: n, visuallyFocussedItem: i } = o, { getItems: s, subscribe: a } = me(void 0), m = l.useRef(null), [d, x] = l.useState(!1), p = _(c, m), u = l.useMemo(() => i === s().find((C) => C.ref.current === m.current)?.ref.current, [s, i]), h = ne(), v = () => {
    !e && n && (o.onValueChange(n), o.onTextValueChange(n), o.onOpenChange(!1), o.autocomplete.type === "both" && o.onFilterValueChange(n), o.trigger?.focus({ preventScroll: !0 }));
  };
  return L(() => {
    const C = a((b) => {
      x(!b.some((g) => g.textValue === n && g.type !== "create"));
    });
    return s().length === 0 && x(!0), () => {
      C();
    };
  }, [n, a, s]), !n || !d ? null : /* @__PURE__ */ f(
    ie.ItemSlot,
    {
      scope: void 0,
      value: n ?? "",
      textValue: n ?? "",
      disabled: e,
      isVisible: !0,
      type: "create",
      children: /* @__PURE__ */ f(
        N.div,
        {
          role: "option",
          tabIndex: e ? void 0 : -1,
          "aria-disabled": e || void 0,
          "data-disabled": e ? "" : void 0,
          "data-highlighted": u ? "" : void 0,
          ...t,
          id: h,
          ref: p,
          onPointerUp: T(t.onPointerUp, v)
        }
      )
    }
  );
});
Mt.displayName = "ComboboxCreateItem";
const ao = so, uo = xt, po = vt, fo = bt, mo = yt, ho = St, go = Vt, xo = Le, Co = Nt, vo = At, bo = _t, yo = Mt;
function So(r, c) {
  const e = Math.min(r.length, c.length);
  for (let t = 0; t < e; t++)
    if (r[t] !== c[t])
      return t;
  return e;
}
const En = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ComboboxItem: Le,
  Content: ho,
  CreateItem: yo,
  Icon: fo,
  Item: xo,
  ItemIndicator: vo,
  ItemText: Co,
  NoValueFound: bo,
  Portal: mo,
  Root: ao,
  TextInput: po,
  Trigger: uo,
  Viewport: go
}, Symbol.toStringTag, { value: "Module" })), Io = [" ", "Enter", "ArrowUp", "ArrowDown"], wo = [" ", "Enter"], he = "Select", [be, ge, To] = Gt(he), [ae, Vo] = st(he, [
  To,
  dt
]), ye = dt(), [Po, q] = ae(he), [Eo, No] = ae(he), He = (r) => {
  const {
    __scopeSelect: c,
    children: e,
    open: t,
    defaultOpen: o,
    onOpenChange: n,
    value: i,
    defaultValue: s,
    onValueChange: a,
    dir: m,
    // name,
    // autoComplete,
    disabled: d,
    required: x,
    multi: p = !1
  } = r, u = ye(c), [h, v] = l.useState(null), [C, b] = l.useState(null), [g, I] = l.useState(!1), E = jt(m), [M = !1, R] = ce({
    prop: t,
    defaultProp: o,
    onChange: n
  }), [A, k] = ce({
    prop: i,
    defaultProp: s,
    onChange(O) {
      a && (Array.isArray(O), a(O));
    }
  }), X = l.useRef(null), [z, B] = l.useState(/* @__PURE__ */ new Set());
  return /* @__PURE__ */ f(re.Root, { ...u, children: /* @__PURE__ */ f(
    Po,
    {
      required: x,
      scope: c,
      trigger: h,
      onTriggerChange: v,
      valueNode: C,
      onValueNodeChange: b,
      valueNodeHasChildren: g,
      onValueNodeHasChildrenChange: I,
      contentId: ne(),
      value: A,
      onValueChange: k,
      open: M,
      onOpenChange: R,
      dir: E,
      triggerPointerDownPosRef: X,
      disabled: d,
      multi: p,
      children: /* @__PURE__ */ f(be.Provider, { scope: c, children: /* @__PURE__ */ f(
        Eo,
        {
          scope: r.__scopeSelect,
          onNativeOptionAdd: l.useCallback((O) => {
            B((H) => new Set(H).add(O));
          }, []),
          onNativeOptionRemove: l.useCallback((O) => {
            B((H) => {
              const F = new Set(H);
              return F.delete(O), F;
            });
          }, []),
          children: e
        }
      ) })
    }
  ) });
};
He.displayName = he;
const Ot = "SelectTrigger", $e = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, ...t } = r, o = ye(e), n = q(Ot, e), i = n.disabled, s = _(c, n.onTriggerChange), a = ge(e), [m, d, x] = Wt((u) => {
      const h = a().filter((b) => !b.disabled), v = h.find((b) => b.value === n.value), C = Kt(h, u, v);
      if (C !== void 0 && !Array.isArray(C.value)) {
        const b = n.multi ? [C.value] : C.value;
        n.onValueChange(b);
      }
    }), p = () => {
      i || (n.onOpenChange(!0), x());
    };
    return /* @__PURE__ */ f(re.Anchor, { asChild: !0, ...o, children: /* @__PURE__ */ f(
      N.div,
      {
        role: "combobox",
        "aria-controls": n.contentId,
        "aria-expanded": n.open,
        "aria-required": n.required,
        "aria-autocomplete": "none",
        dir: n.dir,
        "data-state": n.open ? "open" : "closed",
        "data-disabled": i ? "" : void 0,
        "data-placeholder": n.value === void 0 ? "" : void 0,
        tabIndex: i ? void 0 : 0,
        ...t,
        ref: s,
        onClick: T(t.onClick, (u) => {
          u.currentTarget.focus();
        }),
        onPointerDown: T(t.onPointerDown, (u) => {
          const h = u.target;
          h.hasPointerCapture(u.pointerId) && h.releasePointerCapture(u.pointerId), (h.closest("button") ?? h.closest("div")) === u.currentTarget && u.button === 0 && u.ctrlKey === !1 && (p(), n.triggerPointerDownPosRef.current = {
            x: Math.round(u.pageX),
            y: Math.round(u.pageY)
          }, u.preventDefault());
        }),
        onKeyDown: T(t.onKeyDown, (u) => {
          const h = m.current !== "", v = u.ctrlKey || u.altKey || u.metaKey, C = u.target;
          (C.closest("button") ?? C.closest("div")) === u.currentTarget && (!v && u.key.length === 1 && d(u.key), !(h && u.key === " ") && Io.includes(u.key) && (p(), u.preventDefault()));
        })
      }
    ) });
  }
);
$e.displayName = Ot;
const Dt = "SelectValue", Ue = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, children: t, placeholder: o, ...n } = r, i = q(Dt, e), { onValueNodeHasChildrenChange: s } = i, a = t !== void 0, m = _(c, i.onValueNodeChange), [d, x] = l.useState([]), p = ge(e);
    L(() => {
      s(a);
    }, [s, a]), l.useLayoutEffect(() => {
      if (Array.isArray(i.value) && d.length !== i.value.length) {
        const h = setTimeout(() => {
          const v = p().filter(
            (C) => Array.isArray(C.value) ? !1 : i.value?.includes(C.value)
          );
          x(v);
        });
        return () => {
          clearTimeout(h);
        };
      }
    }, [i.value, p, d]);
    let u;
    if ((i.value === void 0 || i.value.length === 0) && o !== void 0)
      u = /* @__PURE__ */ f("span", { children: o });
    else if (typeof t == "function")
      if (Array.isArray(i.value)) {
        const h = i.value.map((v) => {
          const C = d.find((b) => b.value === v);
          return C ? t({ value: v, textValue: C?.textValue }) : null;
        });
        u = h.every((v) => v === null) ? o : h;
      } else
        u = t(i.value);
    else
      u = t;
    return /* @__PURE__ */ f(N.span, { ...n, ref: m, children: u || null });
  }
);
Ue.displayName = Dt;
const Ro = "SelectIcon", We = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, children: t, ...o } = r;
    return /* @__PURE__ */ f(N.span, { "aria-hidden": !0, ...o, ref: c, children: t || "▼" });
  }
);
We.displayName = Ro;
const Ao = "SelectPortal", Ke = (r) => /* @__PURE__ */ f(pt, { asChild: !0, ...r });
Ke.displayName = Ao;
const oe = "SelectContent", ze = l.forwardRef(
  (r, c) => {
    const e = q(oe, r.__scopeSelect), [t, o] = l.useState();
    if (L(() => {
      o(new DocumentFragment());
    }, []), !e.open) {
      const n = t;
      return n ? Ce.createPortal(
        /* @__PURE__ */ f(kt, { scope: r.__scopeSelect, children: /* @__PURE__ */ f(be.Slot, { scope: r.__scopeSelect, children: /* @__PURE__ */ f("div", { children: r.children }) }) }),
        n
      ) : null;
    }
    return /* @__PURE__ */ f(Ft, { ...r, ref: c });
  }
);
ze.displayName = oe;
const Y = 10, [kt, J] = ae(oe), _o = "SelectContentImpl", Ft = l.forwardRef(
  (r, c) => {
    const {
      __scopeSelect: e,
      position: t = "item-aligned",
      onCloseAutoFocus: o,
      onEscapeKeyDown: n,
      onPointerDownOutside: i,
      //
      // PopperContent props
      side: s,
      sideOffset: a,
      align: m,
      alignOffset: d,
      arrowPadding: x,
      collisionBoundary: p,
      collisionPadding: u,
      sticky: h,
      hideWhenDetached: v,
      avoidCollisions: C,
      //
      ...b
    } = r, g = q(oe, e), [I, E] = l.useState(null), [M, R] = l.useState(null), A = _(c, (y) => E(y)), [k, X] = l.useState(null), [z, B] = l.useState(null), O = ge(e), [H, F] = l.useState(!1), G = l.useRef(!1);
    l.useEffect(() => {
      if (I)
        return ft(I);
    }, [I]), at();
    const j = l.useCallback(
      (y) => {
        const [V, ...D] = O().map((P) => P.ref.current), [S] = D.slice(-1), w = document.activeElement;
        for (const P of y)
          if (P === w || (P?.scrollIntoView({ block: "nearest" }), P === V && M && (M.scrollTop = 0), P === S && M && (M.scrollTop = M.scrollHeight), P?.focus(), document.activeElement !== w))
            return;
      },
      [O, M]
    ), $ = l.useCallback(
      () => j([k, I]),
      [j, k, I]
    );
    l.useEffect(() => {
      H && $();
    }, [H, $]);
    const { onOpenChange: Z, triggerPointerDownPosRef: U } = g;
    l.useEffect(() => {
      if (I) {
        let y = { x: 0, y: 0 };
        const V = (S) => {
          y = {
            x: Math.abs(Math.round(S.pageX) - (U.current?.x ?? 0)),
            y: Math.abs(Math.round(S.pageY) - (U.current?.y ?? 0))
          };
        }, D = (S) => {
          y.x <= 10 && y.y <= 10 ? S.preventDefault() : I.contains(S.target) || Z(!1), document.removeEventListener("pointermove", V), U.current = null;
        };
        return U.current !== null && (document.addEventListener("pointermove", V), document.addEventListener("pointerup", D, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", V), document.removeEventListener("pointerup", D, { capture: !0 });
        };
      }
    }, [I, Z, U]), l.useEffect(() => {
      const y = () => Z(!1);
      return window.addEventListener("blur", y), window.addEventListener("resize", y), () => {
        window.removeEventListener("blur", y), window.removeEventListener("resize", y);
      };
    }, [Z]);
    const [ue, le] = Wt((y) => {
      const V = O().filter((w) => !w.disabled), D = V.find((w) => w.ref.current === document.activeElement), S = Kt(V, y, D);
      S && setTimeout(() => S.ref.current.focus());
    }), de = l.useCallback(
      (y, V, D) => {
        const S = !G.current && !D;
        (g.value !== void 0 && g.value === V || S) && (X(y), S && (G.current = !0));
      },
      [g.value]
    ), pe = l.useCallback(() => I?.focus(), [I]), W = l.useCallback(
      (y, V, D) => {
        const S = !G.current && !D;
        (g.value !== void 0 && (Array.isArray(V) ? V.every((P) => g.value?.includes(P)) : g.value === V) || S) && B(y);
      },
      [g.value]
    ), se = t === "popper" ? Ee : Lt, Q = se === Ee ? {
      side: s,
      sideOffset: a,
      align: m,
      alignOffset: d,
      arrowPadding: x,
      collisionBoundary: p,
      collisionPadding: u,
      sticky: h,
      hideWhenDetached: v,
      avoidCollisions: C
    } : {};
    return /* @__PURE__ */ f(
      kt,
      {
        scope: e,
        content: I,
        viewport: M,
        onViewportChange: R,
        itemRefCallback: de,
        selectedItem: k,
        onItemLeave: pe,
        itemTextRefCallback: W,
        focusSelectedItem: $,
        selectedItemText: z,
        position: t,
        isPositioned: H,
        searchRef: ue,
        children: /* @__PURE__ */ f(mt, { as: Ve, allowPinchZoom: !0, children: /* @__PURE__ */ f(
          ut,
          {
            asChild: !0,
            trapped: g.open,
            onMountAutoFocus: (y) => {
              y.preventDefault();
            },
            onUnmountAutoFocus: T(o, (y) => {
              g.trigger?.focus({ preventScroll: !0 }), document.getSelection()?.empty(), y.preventDefault();
            }),
            children: /* @__PURE__ */ f(
              it,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: n,
                onPointerDownOutside: i,
                onFocusOutside: (y) => y.preventDefault(),
                onDismiss: () => g.onOpenChange(!1),
                children: /* @__PURE__ */ f(
                  se,
                  {
                    role: "listbox",
                    id: g.contentId,
                    "data-state": g.open ? "open" : "closed",
                    "aria-multiselectable": g.multi ? "true" : void 0,
                    dir: g.dir,
                    onContextMenu: (y) => y.preventDefault(),
                    ...b,
                    ...Q,
                    onPlaced: () => F(!0),
                    ref: A,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...b.style
                    },
                    onKeyDown: T(b.onKeyDown, (y) => {
                      const V = y.ctrlKey || y.altKey || y.metaKey;
                      if (y.key === "Tab" && y.preventDefault(), !V && y.key.length === 1 && le(y.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(y.key)) {
                        let S = O().filter((w) => !w.disabled).map((w) => w.ref.current);
                        if (["ArrowUp", "End"].includes(y.key) && (S = S.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(y.key)) {
                          const w = y.target, P = S.indexOf(w);
                          S = S.slice(P + 1);
                        }
                        setTimeout(() => j(S)), y.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
Ft.displayName = _o;
const Mo = "SelectItemAlignedPosition", Lt = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, onPlaced: t, ...o } = r, n = q(oe, e), i = J(oe, e), [s, a] = l.useState(null), [m, d] = l.useState(null), x = _(c, (A) => d(A)), p = ge(e), u = l.useRef(!1), h = l.useRef(!0), { viewport: v, selectedItem: C, selectedItemText: b, focusSelectedItem: g } = i, I = l.useCallback(() => {
      if (n.trigger && n.valueNode && s && m && v && C && b) {
        const A = n.trigger.getBoundingClientRect(), k = m.getBoundingClientRect(), X = n.valueNode.getBoundingClientRect(), z = b.getBoundingClientRect();
        if (n.dir !== "rtl") {
          const w = z.left - k.left, P = X.left - w, ee = A.left - P, te = A.width + ee, Se = Math.max(te, k.width), Ie = window.innerWidth - Y, we = rt(P, [Y, Ie - Se]);
          s.style.minWidth = `${te}px`, s.style.left = `${we}px`;
        } else {
          const w = k.right - z.right, P = window.innerWidth - X.right - w, ee = window.innerWidth - A.right - P, te = A.width + ee, Se = Math.max(te, k.width), Ie = window.innerWidth - Y, we = rt(P, [Y, Ie - Se]);
          s.style.minWidth = `${te}px`, s.style.right = `${we}px`;
        }
        const B = p(), O = window.innerHeight - Y * 2, H = v.scrollHeight, F = window.getComputedStyle(m), G = parseInt(F.borderTopWidth, 10), j = parseInt(F.paddingTop, 10), $ = parseInt(F.borderBottomWidth, 10), Z = parseInt(F.paddingBottom, 10), U = G + j + H + Z + $, ue = Math.min(C.offsetHeight * 5, U), le = window.getComputedStyle(v), de = parseInt(le.paddingTop, 10), pe = parseInt(le.paddingBottom, 10), W = A.top + A.height / 2 - Y, se = O - W, Q = C.offsetHeight / 2, y = C.offsetTop + Q, V = G + j + y, D = U - V;
        if (V <= W) {
          const w = C === B[B.length - 1].ref.current;
          s.style.bottom = "0px";
          const P = m.clientHeight - v.offsetTop - v.offsetHeight, ee = Math.max(
            se,
            Q + // viewport might have padding bottom, include it to avoid a scrollable viewport
            (w ? pe : 0) + P + $
          ), te = V + ee;
          s.style.height = `${te}px`;
        } else {
          const w = C === B[0].ref.current;
          s.style.top = "0px";
          const ee = Math.max(
            W,
            G + v.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
            (w ? de : 0) + Q
          ) + D;
          s.style.height = `${ee}px`, v.scrollTop = V - W + v.offsetTop;
        }
        s.style.margin = `${Y}px 0`, s.style.minHeight = `${ue}px`, s.style.maxHeight = `${O}px`, t?.(), requestAnimationFrame(() => u.current = !0);
      }
    }, [
      p,
      n.trigger,
      n.valueNode,
      s,
      m,
      v,
      C,
      b,
      n.dir,
      t
    ]);
    L(() => I(), [I]);
    const [E, M] = l.useState();
    L(() => {
      m && M(window.getComputedStyle(m).zIndex);
    }, [m]);
    const R = l.useCallback(
      (A) => {
        A && h.current === !0 && (I(), g?.(), h.current = !1);
      },
      [I, g]
    );
    return /* @__PURE__ */ f(
      Do,
      {
        scope: e,
        contentWrapper: s,
        shouldExpandOnScrollRef: u,
        onScrollButtonChange: R,
        children: /* @__PURE__ */ f(
          "div",
          {
            ref: a,
            style: {
              display: "flex",
              flexDirection: "column",
              position: "fixed",
              zIndex: E
            },
            children: /* @__PURE__ */ f(
              N.div,
              {
                ...o,
                ref: x,
                style: {
                  // When we get the height of the content, it includes borders. If we were to set
                  // the height without having `boxSizing: 'border-box'` it would be too big.
                  boxSizing: "border-box",
                  // We need to ensure the content doesn't get taller than the wrapper
                  maxHeight: "100%",
                  ...o.style
                }
              }
            )
          }
        )
      }
    );
  }
);
Lt.displayName = Mo;
const Oo = "SelectPopperPosition", Ee = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, align: t = "start", collisionPadding: o = Y, ...n } = r, i = ye(e);
    return /* @__PURE__ */ f(
      re.Content,
      {
        ...i,
        ...n,
        ref: c,
        align: t,
        collisionPadding: o,
        style: {
          // Ensure border-box for floating-ui calculations
          boxSizing: "border-box",
          ...n.style,
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
Ee.displayName = Oo;
const [Do, Ge] = ae(
  oe,
  {}
), Ne = "SelectViewport", je = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, ...t } = r, o = J(Ne, e), n = Ge(Ne, e), i = _(c, o.onViewportChange), s = l.useRef(0);
    return /* @__PURE__ */ Me(Oe, { children: [
      /* @__PURE__ */ f(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          }
        }
      ),
      /* @__PURE__ */ f(be.Slot, { scope: e, children: /* @__PURE__ */ f(
        N.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...t,
          ref: i,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            overflow: "auto",
            ...t.style
          },
          onScroll: T(t.onScroll, (a) => {
            const m = a.currentTarget, { contentWrapper: d, shouldExpandOnScrollRef: x } = n;
            if (x?.current && d) {
              const p = Math.abs(s.current - m.scrollTop);
              if (p > 0) {
                const u = window.innerHeight - Y * 2, h = parseFloat(d.style.minHeight), v = parseFloat(d.style.height), C = Math.max(h, v);
                if (C < u) {
                  const b = C + p, g = Math.min(u, b), I = b - g;
                  d.style.height = `${g}px`, d.style.bottom === "0px" && (m.scrollTop = I > 0 ? I : 0, d.style.justifyContent = "flex-end");
                }
              }
            }
            s.current = m.scrollTop;
          })
        }
      ) })
    ] });
  }
);
je.displayName = Ne;
const Bt = "SelectGroup", [ko, Fo] = ae(Bt), Ye = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, ...t } = r, o = ne();
    return /* @__PURE__ */ f(ko, { scope: e, id: o, children: /* @__PURE__ */ f(N.div, { role: "group", "aria-labelledby": o, ...t, ref: c }) });
  }
);
Ye.displayName = Bt;
const Ht = "SelectLabel", qe = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, ...t } = r, o = Fo(Ht, e);
    return /* @__PURE__ */ f(N.div, { id: o.id, ...t, ref: c });
  }
);
qe.displayName = Ht;
const xe = "SelectItem", [Lo, $t] = ae(xe), Xe = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, value: t, disabled: o = !1, textValue: n, ...i } = r, s = q(xe, e), a = J(xe, e), m = typeof t == "string" ? Array.isArray(s.value) ? s.value.includes(t) : s.value === t : t.every((g) => s.value?.includes(g)), d = Array.isArray(s.value) && Array.isArray(t) && t.some((g) => s.value?.includes(g)), [x, p] = l.useState(n ?? ""), [u, h] = l.useState(!1), v = _(
      c,
      (g) => a.itemRefCallback?.(g, t, o)
    ), C = ne(), b = () => {
      if (!o) {
        let g = s.multi && typeof t == "string" ? [t] : t;
        d && !m ? s.onValueChange(g) : Array.isArray(s.value) && (g = zt(t, s.value)), s.onValueChange(g), s.multi || s.onOpenChange(!1);
      }
    };
    if (!s.multi && Array.isArray(t))
      throw new Error("You can only pass an array of values in multi selects");
    return /* @__PURE__ */ f(
      Lo,
      {
        scope: e,
        value: t,
        disabled: o,
        textId: C,
        isSelected: m,
        isIntermediate: d,
        onItemTextChange: l.useCallback((g) => {
          p((I) => I || (g?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ f(be.ItemSlot, { scope: e, value: t, disabled: o, textValue: x, children: /* @__PURE__ */ f(
          N.div,
          {
            role: "option",
            "aria-labelledby": C,
            "data-highlighted": u ? "" : void 0,
            "aria-selected": s.multi ? void 0 : m && u,
            "aria-checked": s.multi ? m : void 0,
            "data-state": m ? "checked" : "unchecked",
            "aria-disabled": o || void 0,
            "data-disabled": o ? "" : void 0,
            tabIndex: o ? void 0 : -1,
            ...i,
            ref: v,
            onFocus: T(i.onFocus, () => h(!0)),
            onBlur: T(i.onBlur, () => h(!1)),
            onPointerUp: T(i.onPointerUp, b),
            onPointerMove: T(i.onPointerMove, (g) => {
              o ? a.onItemLeave?.() : g.currentTarget.focus({ preventScroll: !0 });
            }),
            onPointerLeave: T(i.onPointerLeave, (g) => {
              g.currentTarget === document.activeElement && a.onItemLeave?.();
            }),
            onKeyDown: T(i.onKeyDown, (g) => {
              a.searchRef?.current !== "" && g.key === " " || (wo.includes(g.key) && b(), g.key === " " && g.preventDefault());
            })
          }
        ) })
      }
    );
  }
);
Xe.displayName = xe;
const fe = "SelectItemText", Ze = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, className: t, style: o, ...n } = r, i = q(fe, e), s = J(fe, e), a = $t(fe, e), m = No(fe, e), [d, x] = l.useState(null), p = _(
      c,
      (b) => x(b),
      a.onItemTextChange,
      (b) => s.itemTextRefCallback?.(b, a.value, a.disabled)
    ), u = d?.textContent, h = l.useMemo(
      () => /* @__PURE__ */ f(
        "option",
        {
          value: a.value,
          disabled: a.disabled,
          children: u
        },
        Array.isArray(a.value) ? a.value.join(";") : a.value
      ),
      [a.disabled, a.value, u]
    ), { onNativeOptionAdd: v, onNativeOptionRemove: C } = m;
    return L(() => (v(h), () => C(h)), [v, C, h]), /* @__PURE__ */ Me(Oe, { children: [
      /* @__PURE__ */ f(N.span, { id: a.textId, ...n, ref: p }),
      a.isSelected && i.valueNode && !i.valueNodeHasChildren ? Ce.createPortal(n.children, i.valueNode) : null
    ] });
  }
);
Ze.displayName = fe;
const Ut = "SelectItemIndicator", Je = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, children: t, ...o } = r, n = $t(Ut, e);
    return typeof t == "function" ? /* @__PURE__ */ f(N.span, { "aria-hidden": !0, ...o, ref: c, children: t({
      isSelected: n.isSelected,
      isIntermediate: n.isIntermediate
    }) }) : n.isSelected ? /* @__PURE__ */ f(N.span, { "aria-hidden": !0, ...o, ref: c, children: t }) : null;
  }
);
Je.displayName = Ut;
const Re = "SelectScrollUpButton", Qe = l.forwardRef(
  (r, c) => {
    const e = J(Re, r.__scopeSelect), t = Ge(Re, r.__scopeSelect), [o, n] = l.useState(!1), i = _(c, t.onScrollButtonChange);
    return L(() => {
      if (e.viewport && e.isPositioned) {
        const s = e.viewport, a = () => {
          const m = s.scrollTop > 0;
          n(m);
        };
        return a(), s.addEventListener("scroll", a), () => s.removeEventListener("scroll", a);
      }
    }, [e.viewport, e.isPositioned]), o ? /* @__PURE__ */ f(
      tt,
      {
        ...r,
        ref: i,
        onAutoScroll: () => {
          const { viewport: s, selectedItem: a } = e;
          s && a && (s.scrollTop -= a.offsetHeight);
        }
      }
    ) : null;
  }
);
Qe.displayName = Re;
const Ae = "SelectScrollDownButton", et = l.forwardRef(
  (r, c) => {
    const e = J(Ae, r.__scopeSelect), t = Ge(Ae, r.__scopeSelect), [o, n] = l.useState(!1), i = _(c, t.onScrollButtonChange);
    return L(() => {
      if (e.viewport && e.isPositioned) {
        const s = e.viewport, a = () => {
          const m = s.scrollHeight - s.clientHeight, d = Math.ceil(s.scrollTop) < m;
          n(d);
        };
        return a(), s.addEventListener("scroll", a), () => s.removeEventListener("scroll", a);
      }
    }, [e.viewport, e.isPositioned]), o ? /* @__PURE__ */ f(
      tt,
      {
        ...r,
        ref: i,
        onAutoScroll: () => {
          const { viewport: s, selectedItem: a } = e;
          s && a && (s.scrollTop += a.offsetHeight);
        }
      }
    ) : null;
  }
);
et.displayName = Ae;
const tt = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, onAutoScroll: t, ...o } = r, n = J("SelectScrollButton", e), i = l.useRef(null), s = ge(e), a = l.useCallback(() => {
      i.current !== null && (window.clearInterval(i.current), i.current = null);
    }, []);
    return l.useEffect(() => () => a(), [a]), L(() => {
      s().find((d) => d.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" });
    }, [s]), /* @__PURE__ */ f(
      N.div,
      {
        "aria-hidden": !0,
        ...o,
        ref: c,
        style: { flexShrink: 0, ...o.style },
        onPointerMove: T(o.onPointerMove, () => {
          n.onItemLeave?.(), i.current === null && (i.current = window.setInterval(t, 50));
        }),
        onPointerLeave: T(o.onPointerLeave, () => {
          a();
        })
      }
    );
  }
);
tt.displayName = "SelectScrollButtonImpl";
const Bo = "SelectSeparator", ot = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, ...t } = r;
    return /* @__PURE__ */ f(N.div, { "aria-hidden": !0, ...t, ref: c });
  }
);
ot.displayName = Bo;
const _e = "SelectArrow", nt = l.forwardRef(
  (r, c) => {
    const { __scopeSelect: e, ...t } = r, o = ye(e), n = q(_e, e), i = J(_e, e);
    return n.open && i.position === "popper" ? /* @__PURE__ */ f(re.Arrow, { ...o, ...t, ref: c }) : null;
  }
);
nt.displayName = _e;
const Ho = "BubbleSelect", $o = l.forwardRef(
  (r, c) => {
    const { value: e, ...t } = r, o = l.useRef(null), n = _(c, o), i = Yt(e), s = q(Ho, void 0);
    l.useEffect(() => {
      const m = o.current, d = window.HTMLSelectElement.prototype, p = Object.getOwnPropertyDescriptor(d, "value").set;
      if (i !== e && p) {
        const u = new Event("change", { bubbles: !0 });
        p.call(m, e), m.dispatchEvent(u);
      }
    }, [i, e]);
    let a = e;
    return s.multi && !Array.isArray(e) && (a = []), /* @__PURE__ */ f(qt, { asChild: !0, children: /* @__PURE__ */ f(
      "select",
      {
        ...t,
        multiple: s.multi ? !0 : void 0,
        ref: n,
        defaultValue: a
      }
    ) });
  }
);
$o.displayName = "BubbleSelect";
function Wt(r) {
  const c = Xt(r), e = l.useRef(""), t = l.useRef(0), o = l.useCallback(
    (i) => {
      const s = e.current + i;
      c(s), function a(m) {
        e.current = m, window.clearTimeout(t.current), m !== "" && (t.current = window.setTimeout(() => a(""), 1e3));
      }(s);
    },
    [c]
  ), n = l.useCallback(() => {
    e.current = "", window.clearTimeout(t.current);
  }, []);
  return l.useEffect(() => () => window.clearTimeout(t.current), []), [e, o, n];
}
function Kt(r, c, e) {
  const o = c.length > 1 && Array.from(c).every((m) => m === c[0]) ? c[0] : c, n = e ? r.indexOf(e) : -1;
  let i = Uo(r, Math.max(n, 0));
  o.length === 1 && (i = i.filter((m) => m !== e));
  const a = i.find((m) => m.textValue.toLowerCase().startsWith(o.toLowerCase()));
  return a !== e ? a : void 0;
}
function Uo(r, c) {
  return r.map((e, t) => r[(c + t) % r.length]);
}
const zt = (r, c = []) => {
  if (Array.isArray(r))
    return r.reduce((t, o) => zt(o, t), c);
  const e = c.indexOf(r);
  return e === -1 ? [...c, r] : [...c.slice(0, e), ...c.slice(e + 1)];
}, Wo = He, Ko = $e, zo = Ue, Go = We, jo = Ke, Yo = ze, qo = je, Xo = Ye, Zo = qe, Jo = Xe, Qo = Ze, en = Je, tn = Qe, on = et, nn = ot, rn = nt, Nn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arrow: rn,
  Content: Yo,
  Group: Xo,
  Icon: Go,
  Item: Jo,
  ItemIndicator: en,
  ItemText: Qo,
  Label: Zo,
  Portal: jo,
  Root: Wo,
  ScrollDownButton: on,
  ScrollUpButton: tn,
  Select: He,
  SelectArrow: nt,
  SelectContent: ze,
  SelectGroup: Ye,
  SelectIcon: We,
  SelectItem: Xe,
  SelectItemIndicator: Je,
  SelectItemText: Ze,
  SelectLabel: qe,
  SelectPortal: Ke,
  SelectScrollDownButton: et,
  SelectScrollUpButton: Qe,
  SelectSeparator: ot,
  SelectTrigger: $e,
  SelectValue: Ue,
  SelectViewport: je,
  Separator: nn,
  Trigger: Ko,
  Value: zo,
  Viewport: qo,
  createSelectScope: Vo
}, Symbol.toStringTag, { value: "Module" }));
export {
  En as Combobox,
  Nn as Select,
  _n as composeEventHandlers,
  Zt as createCollection,
  On as useCallbackRef,
  Jt as useCollator,
  De as useFilter
};
